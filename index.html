<!DOCTYPE html>












  


<html class="theme-next mist use-motion" lang="zh-CN">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2"/>
<meta name="theme-color" content="#222">












<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />






















<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=6.3.0" rel="stylesheet" type="text/css" />


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=6.3.0">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=6.3.0">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=6.3.0">


  <link rel="mask-icon" href="/images/logo.svg?v=6.3.0" color="#222">









<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Mist',
    version: '6.3.0',
    sidebar: {"position":"left","display":"post","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: false,
    fastclick: false,
    lazyload: false,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>


  




  <meta property="og:type" content="website">
<meta property="og:title" content="renz">
<meta property="og:url" content="https://renzheng0403.github.io/index.html">
<meta property="og:site_name" content="renz">
<meta property="og:locale" content="zh-CN">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="renz">






  <link rel="canonical" href="https://renzheng0403.github.io/"/>



<script type="text/javascript" id="page.configurations">
  CONFIG.page = {
    sidebar: "",
  };
</script>

  <title>renz</title>
  









  <noscript>
  <style type="text/css">
    .use-motion .motion-element,
    .use-motion .brand,
    .use-motion .menu-item,
    .sidebar-inner,
    .use-motion .post-block,
    .use-motion .pagination,
    .use-motion .comments,
    .use-motion .post-header,
    .use-motion .post-body,
    .use-motion .collection-title { opacity: initial; }

    .use-motion .logo,
    .use-motion .site-title,
    .use-motion .site-subtitle {
      opacity: initial;
      top: initial;
    }

    .use-motion {
      .logo-line-before i { left: initial; }
      .logo-line-after i { right: initial; }
    }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-CN">

  
  
    
  

  <div class="container sidebar-position-left 
  page-home">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">renz</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
    
      
        <p class="site-subtitle">what's past is prologue</p>
      
    
  </div>

  <div class="site-nav-toggle">
    <button aria-label="切换导航栏">
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>



<nav class="site-nav">
  
    <ul id="menu" class="menu">
      
        
        
        
          
          <li class="menu-item menu-item-home menu-item-active">
    <a href="/" rel="section">
      <i class="menu-item-icon fa fa-fw fa-home"></i> <br />首页</a>
  </li>
        
        
        
          
          <li class="menu-item menu-item-about">
    <a href="/about/" rel="section">
      <i class="menu-item-icon fa fa-fw fa-user"></i> <br />关于</a>
  </li>
        
        
        
          
          <li class="menu-item menu-item-tags">
    <a href="/tags/" rel="section">
      <i class="menu-item-icon fa fa-fw fa-tags"></i> <br />标签</a>
  </li>
        
        
        
          
          <li class="menu-item menu-item-categories">
    <a href="/categories/" rel="section">
      <i class="menu-item-icon fa fa-fw fa-th"></i> <br />分类</a>
  </li>
        
        
        
          
          <li class="menu-item menu-item-archives">
    <a href="/archives/" rel="section">
      <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />归档</a>
  </li>

      
      
    </ul>
  

  
    

  

  
</nav>



  



</div>
    </header>

    


    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          
          <div id="content" class="content">
            
  <section id="posts" class="posts-expand">
    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://renzheng0403.github.io/2017/11/25/被嫌弃的松子的一生/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="renzheng">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="renz">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2017/11/25/被嫌弃的松子的一生/" itemprop="url">
                  被嫌弃的松子的一生
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">

            
            
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              

              
                
              

              <time title="创建时间：2017-11-25 23:27:00" itemprop="dateCreated datePublished" datetime="2017-11-25T23:27:00+08:00">2017-11-25</time>
            

            
              

              
                
                <span class="post-meta-divider">|</span>
                

                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                
                  <span class="post-meta-item-text">更新于</span>
                
                <time title="修改时间：2018-05-19 09:46:25" itemprop="dateModified" datetime="2018-05-19T09:46:25+08:00">2018-05-19</time>
              
            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/后感/" itemprop="url" rel="index"><span itemprop="name">后感</span></a></span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>从松子的角度来看，被嫌弃的一生其实是追寻的一生。<br>看这个电影，我们可能会像一个看客一样思考，假如松子怎么怎么样。要知道，任何时候我们谈论，假如松子在某个人生的节点如果做出某个在你看来可能更合理的选择都是不客观的。她的一生每一个选择，背后都透露出她的人生态度，这份态度坚决，清晰。<br>这个剧的编剧大概是个太宰治的铁粉，不仅剧中多次出现了相关因素，例如松子被开除后跟随的那个专职作家，自命太宰治的转身;例如杀了合伙人之后选择了结生命的地点。最重要的大概就是该剧与《人间失格》的对比。<br>两部作品构建的根基都是相同的，甚至可能都不是构建，就是赤裸裸的现实。主人公的一生都活在渴望爱却又缺失爱的境地，用刻意扭曲搞怪的面容企图逗乐他人，见证了人性的丑恶，经历的孤独的痛苦，最后在凄惨的年月中年迈死去。不知是否是刻意为之，松子却选择了与叶藏看似不同的选择。</p>
<blockquote>
<p>胆小鬼连幸福都会害怕，碰到棉花都会受伤，有时还会被幸福所伤</p>
</blockquote>
<p>这就是叶藏表现出来的外在性质，但是松子却是一个爱的热烈而坚定的女人。对于太宰治转身的作家男友的爱，对于自杀未遂遇到的理发师的坚守，对于阿龙的生死与共。可是这些在有些人谈论爱情时刻意强调的必备品质并没有为松子带来多少命运的青睐。你会发现撇开人生的意义来单独谈论爱情是没有意义的。纯粹的爱情活在春秋时期，活在希腊史诗中，活在人类文明早期的探索，稍有认知却又认知不全。<br>老实说我对于文学和哲学并没有什么像样的系统学习，只是在某个时期出于本能为了解决自己的性格问题而阅读了一些书，这也是以荒废了理科课程的学习为代价。所以你可以看到，我写的文章都是难登大雅之堂的唠磕。<br>我们在一生之中也会遇到松子的难题，我们都采取了聪明的做法，所以我们看似过得幸福，但是人生也变得没有意义。举身边安稳度日的长辈的例子，相比于那些晚年过得没有他们幸福的长辈来说，他们总是<strong>仿佛</strong>脸上有光。可是他们依然没有得到成长，这就好像做课题研究一样，研究是一件逆熵的过程，总要付出一些代价例如思考、汗水、时间等等，他们避开了这些麻烦，没有接下课题研究的任务，自然也就不会有一个认知的经历过程。可是松子啊，从头到尾都在接受这类课题研究，而且从小到老，随着研究的深入，认知程度也越来越高。如果说人生真的只是一个试炼的话，那么无论是松子还是叶藏，她们都是我们中的佼佼者。<br>写到这里，我也总算对于如何讲述这个感想有了思路，以人生的课题来讲述或许是最符合我的思路，也是我最能把事情将清楚的方式了。</p>
<p>我们先看松子小时候接受的课题吧。要解释这个问题其实也不难，专业术语还真忘了，貌似叫什么情感反馈缺失。也就是说小松子的父母因为太过关心患病的妹妹，忽略了松子的情感需求，就像嗷嗷待哺的雏鸟，长大了嘴却没有被喂食。小松子对于爱的需求，对于焦点的获得，体现在做鬼脸上，这点如出一辙的出现在《人间失格》里。在这个课题上，小松子的处理已经超过很多人了。我妈妈可以举出处理不当的两种反例，这要算我妈最早提出的一个假设。我妈发现一个奇怪的现象，就是有三到四个孩子的家庭里，假如前两个是女孩，那么二女儿的性格通常都会有些怪异。这个例子在我小时候经常生病去的那家医疗室的医生家里很好的体现出来。医疗室是医生夫妇打理，家就在二楼。大女儿又漂亮学习又好，二女儿在学校里打架惹事，穿的也没有医生家里的大小姐，小儿子貌似也挺憨，我那个时候可能只注意大女儿了，年龄比我大不了多少，又很漂亮。我妈的解释是这样的家庭结构，大女儿肯定不会受到忽视，小儿子就更不会了，二女儿可能管教就少了。她还举了我姑家的例子，不过好在我姑对孩子真的是一视同仁，尽管如此二女儿还是有点点怪异。最后我妈又举了自己的例子，我才意识到原来是深有体会。我妈在怀我的时候的那个爆炸头照片现在还很前卫。松子呢，同样的受到忽视，但是没有打架斗殴自暴自弃，也没有沉默寡言自卑自弱，而是学会了鬼脸斗父亲笑，可以说很积极了，又有多少家小孩可以做到这点呢。而且松子通过这招，稍微的达成了焦点的吸引。</p>
<p>第二个课题出现在松子做中学教师的时候。这个课题是没有成功处理的吧，应该是受小时候的影响太深了。这个课题归结为<strong>对他人的需求</strong>。松子在与人面对面交流的时候很难对人说NO，当阿龙在她面前的时候，当阿龙拿出信任这把武器的时候，松子宁愿推翻”是阿龙偷的“这个结论也要提供给阿龙信任，只有当阿龙走的时候才又从新建立结论。当面对店铺老板坚决要求小偷必须当场道歉的时候，情急之前使用本能——做鬼脸，也没有拒绝见小偷这个要求。不敢拒绝，最终生出妥协，成了牺牲品。这个课题是有些难度的，老实说换作是你也不能在段时间内很好的解决。<br>由于这个课题的因是第一个课题的果，导致松子崩溃，进而也将第一个课题的隐患引爆——嫉妒受到关注与呵护的妹妹。</p>
<p>第三个课题算是<strong>爱情与归宿</strong>，但是爱情占据大半，归宿的意味没有后面有个课题强。这个时期的松子与家人断绝了关系，有了一个自比于太宰治转世的男友，可是啊，我相信无论是太宰治还是他小说的主人公，都不会对女性施暴，他们对于女性的态度应该是谄媚和逗乐居多，要么逃避，绝不会出现施暴这一回，这点编剧是不是真心理解偏了，我觉得如果把施暴换成对女性的隐形勾引会更符合太宰治化身这一形象。而且这里的施暴和后面阿龙的施暴明显重合。如果参考《维庸之妻》设计这段情节会更符合。但是无论怎样，这个专职作家都不是一个好的归宿，至于为什么会对这样的人产生爱情，还有爱情究竟是真的还是只是一种表象，对不起，不知道。事实就是松子爱的坚定，爱的不可理喻，爱的遍体鳞伤。<br>在这个课题上，每个人都有每个人的见解，我也和你们一样认为如果施暴，为什么还要在一起，是受虐习惯了吗？会选择离开，但是松子在这个课题上可能还真的做的更好一点。她认定了那就是爱情，事实证明这点她没有错，不会象我们一样因为某些客观因素选择放弃，其实就是放弃爱情。作家自杀后，她也就失去了爱情。爱情的恨与别，折磨与不舍，松子在这个课题里都提会了。</p>
<p>第四个课题延续了第二个课题，即<strong>对他人说NO</strong>的能力。在这个课题里面，松子绝对是选择了一个任性而三观级正的做法，让我们得以看见一个人生逐渐成熟的松子。<br>松子与人合伙做生意，但是合伙人毁约并私吞了松子的心血，在合伙人的欺凌下，松子内心毫无波澜（可能说错了，是很气愤），我们可以看到松子与合伙人直接的心理对峙外加身体反抗。我记得电影里在之前好像铺垫说是作家死了万念俱灰，做这样一个铺垫我不能认同，这是不切和生活的小说的写法，但既然是太宰治流，那么绝对离不开心理的变革。<br>松子在整体上是一个面对困难积极寻找解决办法的人，第一个课题里就讲到她在面对情感反馈缺失就解决的很好，那么在后来她应该会从第二个课题的处理失败中找到正确的处理办法——说NO。而且她说的很彻底，将合伙人杀了。<br>这个课题我不知道你们怎么看，但是我觉得很爽，这是一个已经成熟的人了，如果是这时候的松子来处理第二个课题，那么就不会出现这么多的事情了。人无论怎么犯错，都不过是一个经历与否的问题，所以不要说松子应该怎样做，她做不到的你绝对做不到，因为她代表的是小说家抽象出来的假设，是一种贴近真实的理想状态。</p>
<p>第五个课题就是彻底的<strong>归宿感</strong>了，也是让人忍不住泪目的地方。自杀未遂的松子遇见的理发师就代表了这样一种状态，他其貌不扬，有着中年普通人发福的面孔，做着安稳的职业过着安稳的一生，脾气温柔对人友善，对于经历过这么多的松子来说极具诱惑力。也就是在这个港湾里松子体会到了生活得快乐，我记得这一段镜头特别的祥和，松子也浑身散发圣母的光辉。<br>这是我们普通人认为最明智的选择吧，走到如今这一步的松子也很想就这样生活，所以被警方抓到坐牢，才会眼睛里充满积极的光，对未来的生活充满渴望。在她的想象里，出狱后他就可以与理发师过上这种生活了。可是这种生活得事实是怎样的呢？如果这种生活真的如此理想，为什么文学作品里总是描写不同于此的情况。一种猜想是，这种现实里的生活只是一种妥协。我们对命运低头迷失在了生活得柴米油盐之中，迷失了经由课题感悟人生的可能。这种妥协事实上也是脆弱的，它没有爱情那种强有力的看不见的联系，顶多有某种声称具有法律效率的文件来作为保证。不知道是人类社会的进化还是仅仅作为社会的一种临时状态，说不定我们最终还会重回古时候那种纯粹爱情的时代。<br>挽回正题，出狱的松子怀着怎样的期待不知你能否体会一下，理发店越来越近，走到门口却发现了新的女主人和孩子，松子就这么在门口说了一句早已准备好的台词“我回来了”，离开了，屋内的人谁也没有注意到外面曾有过一个自由的灵魂。<br>你看，即使是松子也和你我一样，败给了归宿感，我们都不愿意再漂泊了。然而这种虚假的归宿感由于其本身的脆弱属性，将松子最后一点希望破灭。</p>
<p>第六个是真正的关于<strong>爱情</strong>的课题了，在这个课题里，你可以也印证了前一个课题 归属感的破灭。我记得在第三个课题里，我没有很好将其归属与<strong>爱情</strong>还是<strong>归宿</strong>，写道这里我自己忽然明白了，因为没有放弃归宿，所以二者兼而有之。但是这里就分得很明确了，最终选择抛弃归宿的松子对于爱情变得更加彻底而疯狂，好像这已经是她最后的精神稻草了。<br>阿龙，这个在第一个课题里将她陷入困境的人，向她坦白了爱意，松子悲愤，只说了句讨厌雨天。只怕是阿龙将从前的事如过山车勾起。<br>回味一下对话：<br><code>你有那么恨我吗？</code><br><code>正相反。</code><br>这样课题涉及的往事不知道该怎么说，如果你想了解什么叫“我只会给松子带来伤害”这段阿龙的内心独白，就一定要看一遍《人间失格》才会懂，大概就是爱到深处才会远离，但是日本人会将这一感情的绝望升华至人生的绝望，才会知道阿龙，这个两度带给松子灾祸的根源，却也因对松子的爱生活在痛苦之中，也算是阿龙的课题吧。阿龙的课题——爱、自我否定。而阿龙在自己的课题——自我否定的错误处理，将松子彻底的推向深渊。<br>到了这一步，阿龙错误的认为自己带给松子的只有痛苦，离开了松子。而松子在对阿龙的期盼落空后，也封闭了自己。<br>另外两个课题分别是友情和偶像，也都以处理失败告终，暂时不想写了，有空再说吧。</p>

          
        
      
    </div>

    

    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://renzheng0403.github.io/2017/11/17/关乎信仰，关乎经历/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="renzheng">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="renz">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2017/11/17/关乎信仰，关乎经历/" itemprop="url">
                  可怕的信仰
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">

            
            
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              

              
                
              

              <time title="创建时间：2017-11-17 23:57:00" itemprop="dateCreated datePublished" datetime="2017-11-17T23:57:00+08:00">2017-11-17</time>
            

            
              

              
                
                <span class="post-meta-divider">|</span>
                

                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                
                  <span class="post-meta-item-text">更新于</span>
                
                <time title="修改时间：2018-05-19 10:03:15" itemprop="dateModified" datetime="2018-05-19T10:03:15+08:00">2018-05-19</time>
              
            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/后感/" itemprop="url" rel="index"><span itemprop="name">后感</span></a></span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>看完《血战钢锯岭》，不得不说还真被Doss的天真无邪给洗了一下我略肮脏的大脑，再加上改编自真人真事，更加让人佩服了。<br>我是相信真有如此信仰坚定之人，虽然不是刻意为之，但是表现确实异于常人。他们好像不懂人情事故，不肯变通，于是我心里不免暗叹一声，涉世未深，涉世未深啊。其实啊，他们究竟经历了哪些生命中不能承受的痛苦，谁也不知道。每次遇到这类人，他们的天真都像一盏发亮的光环，吸引我去观察。<br>我首先揣测，唔，这个家伙，性情乖张，不食人间烟火，肯定是从小生活在安乐乡，偶然性的生活在阳关下，无死角。不对，也许是从小就经历太多已经看淡人生了，你的这点小99在他眼里不算什么。你可以妄加评判一个人的性格，却不能说出这个性格背后代表的真正人格，那么评论一个人的性格又有什么意义呢？<br>如果我没有记错的话，《三体》里记录了一个关于乐观人格和悲观人格的对比。我们先从表象来评判性格。a积极进取，坚信人类科技在有限时间内一定能够取得重大进展，从而能够进行宇宙航行，脱离灭绝的危险，那么我们称a为乐观主义者。b呢，他根据现有的事实推断人类的时间已经不够等到科技成熟的那一天，人类摆脱不了灭绝的结局，我们称b为悲观主义者。<br>事实情况相反，a是一个彻底的悲观主义者，他也一样深知人类的弱小，即使科技取得进步，也有可能被更加强大的外力摧毁，他所做的一切，都是想尽最大的努力逃离地球。正是因为对人类的绝对悲观，才最终促使他即使在人类科技真的取得巨大进展的情况下，仍然义无反顾的选择逃离。这是何等的悲观啊！简直可以媲美那些即使我们国家富强了，也一心想要抓紧移民的人，一模一样啊亲。<br>好了，为什么要说这个呢？只是想说，无论他的表现怎样，你都永远无法判断一个人的真正人格。他有可能在他真人格的基础上发展个变化，而这个变化有几层，你自以为认清了一个人表面下的真正性格究竟是他的第几层面具？<br>那么血战钢锯岭呢？撕掉了第一层表面人格！是的，全片仅仅撕掉了第一层人格，我相信Doss的性格解析做的并没有太深入，所以当我看到他宁愿上军事法庭也不愿意拿枪的时候，给我一个突兀的感觉。在这方面，《阿甘正传》做的挺好的，怎么做到的我已经忘了，但是从头看到尾，乃至今后所做抉择都可能会被他影响。可能阿甘的人格剖析的足够彻底，以至于仿佛我们感到自己度过了他的一生。<br>或许Doss的成型并不来源于经历，而是信仰，即宗教。这真的是我所不能理解的了。我挺想成为一个虔诚的信教徒，但是越是参与宗教，越觉得我可能就是那些站在宗教对立面的原型。甚至一度怀疑自己是不是一个不知道自己是撒旦的撒旦（有点绕）。这或许解释了为什么说归属上帝的人都有福，而有些人归属了上帝却并没有福，因为你在基督的概念里并不是人。<br>Doss对于上帝的信仰无比坚定，而上帝也确实多多加福于他。可能是宗教的力量吧。毫无信仰的可怜鬼真的无比羡慕，在我的眼里，即使真的是上帝创造了我们，那么他的目的可能也只是想知道谁创造的他。</p>

          
        
      
    </div>

    

    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://renzheng0403.github.io/2017/09/30/2017-09-30-mod_pmc模块/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="renzheng">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="renz">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2017/09/30/2017-09-30-mod_pmc模块/" itemprop="url">
                  mod_pmc模块
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">

            
            
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              

              
                
              

              <time title="创建时间：2017-09-30 00:00:00" itemprop="dateCreated datePublished" datetime="2017-09-30T00:00:00+08:00">2017-09-30</time>
            

            
              

              
                
                <span class="post-meta-divider">|</span>
                

                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                
                  <span class="post-meta-item-text">更新于</span>
                
                <time title="修改时间：2018-06-24 23:48:14" itemprop="dateModified" datetime="2018-06-24T23:48:14+08:00">2018-06-24</time>
              
            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/PKI/" itemprop="url" rel="index"><span itemprop="name">PKI</span></a></span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="源代码结构（apache模块结构）"><a href="#源代码结构（apache模块结构）" class="headerlink" title="源代码结构（apache模块结构）"></a>源代码结构（apache模块结构）</h1><p>模块定义：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">module</span> AP_MODULE_DECLARE_DATA pmc_module = &#123;</span><br><span class="line">    STANDARD20_MODULE_STUFF,</span><br><span class="line">    pmc_create_dir_conf,      <span class="comment">/* create per-dir    config structures */</span></span><br><span class="line">    pmc_merge_dir_conf,       <span class="comment">/* merge  per-dir    config structures */</span></span><br><span class="line">    pmc_create_server_conf,   <span class="comment">/* create per-server config structures */</span></span><br><span class="line">    pmc_merge_server_conf,    <span class="comment">/* merge  per-server config structures */</span></span><br><span class="line">    pmc_cmds,                 <span class="comment">/* table of config file commands       */</span></span><br><span class="line">    pmc_register_hooks        <span class="comment">/* register hooks                      */</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>注册钩子处理函数：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">pmc_register_hooks</span><span class="params">(<span class="keyword">apr_pool_t</span> *p)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">/* 注册可选函数 */</span></span><br><span class="line">    APR_REGISTER_OPTIONAL_FN(pmc_check_fail);</span><br><span class="line">    APR_REGISTER_OPTIONAL_FN(pmc_query_attrs);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 日志 */</span></span><br><span class="line">    ap_hook_pre_config(pmc_hook_pre_config, <span class="literal">NULL</span>, <span class="literal">NULL</span>, APR_HOOK_MIDDLE);</span><br><span class="line">    <span class="comment">/* 初始化连接上下文 */</span></span><br><span class="line">    ap_hook_pre_connection(pmc_pre_connection, <span class="literal">NULL</span>, <span class="literal">NULL</span>, APR_HOOK_MIDDLE);</span><br><span class="line">    <span class="comment">/* 检查权限 */</span></span><br><span class="line">    ap_hook_access_checker(pm_permission_check, <span class="literal">NULL</span>, <span class="literal">NULL</span>, APR_HOOK_FIRST);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>指令配置：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">const</span> command_rec pmc_cmds[] =</span><br><span class="line">&#123;</span><br><span class="line">    AP_INIT_TAKE1(<span class="string">"PMCEngine"</span>, cmd_pmc_engine, <span class="literal">NULL</span>, RSRC_CONF, <span class="string">"set pmc engine On or Off"</span>),</span><br><span class="line">    AP_INIT_FLAG(<span class="string">"PMCEngineSkip"</span>, cmd_pmc_engine_skip, <span class="literal">NULL</span>, ACCESS_CONF, <span class="string">"set if pmc is skipped"</span>),</span><br><span class="line">    AP_INIT_TAKE1(<span class="string">"PMCCurlTimeOut"</span>, cmd_pmc_curl_timeout, <span class="literal">NULL</span>, RSRC_CONF, <span class="string">"set pmc curl timeout"</span>),</span><br><span class="line">    AP_INIT_TAKE1(<span class="string">"PMCCurlConnectionTimeOut"</span>, cmd_pmc_curl_connection_timeout, <span class="literal">NULL</span>, RSRC_CONF, <span class="string">"set pmc curl connection timeout"</span>),</span><br><span class="line">    AP_INIT_TAKE1(<span class="string">"PMCControlType"</span>, cmd_pmc_control_type, <span class="literal">NULL</span>, RSRC_CONF, <span class="string">"set pmc control type(Connect or Access)"</span>),</span><br><span class="line">    AP_INIT_TAKE23(<span class="string">"PMCServiceProvider"</span>, cmd_pmc_service_provider, <span class="literal">NULL</span>, RSRC_CONF, <span class="string">"set pmc service provider and uri"</span>),</span><br><span class="line">    AP_INIT_TAKE1(<span class="string">"PMCExtendGranularity"</span>, cmd_pmc_granularity_extend, <span class="literal">NULL</span>, RSRC_CONF, <span class="string">"set pmc entend granularity On or Off"</span>),</span><br><span class="line">    AP_INIT_TAKE1(<span class="string">"PMCUrlEncode"</span>, cmd_pmc_urlencode, <span class="literal">NULL</span>, RSRC_CONF, <span class="string">"set pmc urlencode On or Off"</span>),</span><br><span class="line">    AP_INIT_TAKE1(<span class="string">"PMCEncrypt"</span>, cmd_pmc_encrypt, <span class="literal">NULL</span>, RSRC_CONF, <span class="string">"set pmc encrypt  On or Off"</span>),</span><br><span class="line">    AP_INIT_TAKE2(<span class="string">"PMCEncryptAlgorithm"</span>, cmd_pmc_encrypt_algorithm, <span class="literal">NULL</span>, RSRC_CONF, <span class="string">"set pmc encrypt algorithm"</span>),</span><br><span class="line">    AP_INIT_TAKE1(<span class="string">"PMCFieldUrlDecode"</span>, cmd_pmc_field_urldecode, <span class="literal">NULL</span>, RSRC_CONF, <span class="string">"set pmc field urldecode On or Off"</span>),</span><br><span class="line">    AP_INIT_TAKE1(<span class="string">"PMCUriPattern"</span>, cmd_pmc_uri_pattern, <span class="literal">NULL</span>, RSRC_CONF, <span class="string">"set pmc uri pattern"</span>),</span><br><span class="line">    AP_INIT_TAKE1(<span class="string">"PMCUriRegex"</span>, cmd_pmc_uri_regex, <span class="literal">NULL</span>, RSRC_CONF, <span class="string">"set pmc uri regex"</span>),</span><br><span class="line">    AP_INIT_TAKE23(<span class="string">"PMCHeaderFieldMapping"</span>, cmd_pmc_header_field_mapping, <span class="literal">NULL</span>, RSRC_CONF, <span class="string">"set pmc header field mapping"</span>),</span><br><span class="line">    AP_INIT_TAKE2(<span class="string">"PMCUrlFieldMapping"</span>, cmd_pmc_url_field_mapping, <span class="literal">NULL</span>, RSRC_CONF, <span class="string">"set pmc url field mapping"</span>),</span><br><span class="line"></span><br><span class="line">    &#123;<span class="literal">NULL</span>&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>指令用于在配置文件中设定值。</p>
<p>我自己认为apache这套系统在功能<strong>实现</strong>和<strong>控制</strong>两个方面做的很清晰，在钩子处理函数里面，实现的是业务逻辑，使用的人如果想更改其中的某些选项或者方式，那么只需要通过指令做相应的配置就可以了，即控制。我们想一想魔法世界，巫师并不清楚魔法世界的运作原理，但是使用魔杖念出魔咒，就可以发挥神奇的功效。Apache的指令就是我们的魔咒。还可以自己创造<strong>魔咒</strong>，只要在<code>command_rec pmc_cmds[]</code>里配置并编写相应的函数就能完成。</p>
<p>什么是功能<strong>实现</strong>呢？目前我能想到的和这个系统最像的就是集成电路的制备过程，模块和参数控制，硅片在这个流程里被加工成集成电路，而通过改变设定的参数，你可以控制渗透多少元素或者腐蚀到什么程度。但是这个比喻不好，因为了解这个的人不多。现实中也有同样的例子，或许社会学家就有更形象的例子。</p>
<p>数据来到了这个<code>mod_pmc</code>模块，我想将其设置为接入控制，不需要去分析源代码，改动源代码的结构，只需要在专门设置访问控制的配置文件pmc.conf文件里设置：<code>PMCControlType  Access</code>就可以了。那么接下来在名为<code>PMCControlType  Access</code>的黑盒后面发生了什么？</p>
<p>顺藤摸瓜，在指令配置<code>static const command_rec pmc_cmds[]</code>里发现了<code>AP_INIT_TAKE1(&quot;PMCControlType&quot;, cmd_pmc_control_type, NULL, RSRC_CONF, &quot;set pmc control type(Connect or Access)&quot;),</code>，线索很明确了，<code>cmd_pmc_control_type</code>就是我们下一步要去探访的<strong>函数</strong>，此行吉凶未知，万一他什么也不说，只是给出一副冷冰冰的黑脸怎么办。</p>
<p>我们的在同一个文件<strong>mod_pmc.c</strong>里找到了<code>cmd_pmc_control_type</code>老兄，结果却异常顺利，原来设想的”我不知道啊，某某告诉我的，你去他那里看看“这种对话并没有出现。<code>cmd_pmc_control_type</code>老兄一看就是个实在人，告诉了我他的工作：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">const</span> <span class="keyword">char</span> * <span class="title">cmd_pmc_control_type</span><span class="params">(cmd_parms *params, <span class="keyword">void</span> *dummy, <span class="keyword">const</span> <span class="keyword">char</span> *control_type)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    pmc_module_conf *mconf = ap_get_module_config(params-&gt;server-&gt;module_config, &amp;pmc_module);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (strcasecmp(control_type, <span class="string">"Connect"</span>) == <span class="number">0</span>) &#123;</span><br><span class="line">        mconf-&gt;control_type = CT_CONNECT;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (strcasecmp(control_type, <span class="string">"Access"</span>) == <span class="number">0</span>) &#123;</span><br><span class="line">        mconf-&gt;control_type = CT_ACCESS;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> apr_psprintf(params-&gt;pool, <span class="string">"%s is an invalid control type, must be Connect or Access"</span>, control_type);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>诺，你看，<code>control_type</code>的值也就是<code>cmd_pmc_control_type</code>的值自然是<code>Access</code>，由此将设置<code>mconf-&gt;control_type</code>的值为<code>CT_ACCESS</code>，但是老兄隐藏了<code>ap_get_module_config</code>的线索，我使用人肉搜索也没有找到。包括<code>cmd_params *params</code>参数也没有提供来源，这不重要。重要的是，在钩子处理函数<code>pm_permission_check</code>里看到的通过<code>switch (mconf-&gt;control_type)</code>进行判断有了合理的解释，<code>mconf-&gt;control_type</code>果然是设置好的值，但是与我之前的猜测甚远，并不是在另外某个函数里故意设置的，真相只有一个，那就是<code>cmd_pmc_control_type</code>老兄干的！（此刻响起了名侦探柯南破案成功的音乐）</p>
<p>不要高兴太早，我们还只理清了这个模块的指令的其中一个的实现，举这个例子只是想理清这个模块的架构的大致模样：钩子处理函数处理数据的主要流程，指令注册的函数则对某些参数进行改变，接下来的部分的思路就分两块进行了。</p>
<h1 id="钩子处理函数"><a href="#钩子处理函数" class="headerlink" title="钩子处理函数"></a>钩子处理函数</h1><h2 id="pm-permission-check"><a href="#pm-permission-check" class="headerlink" title="pm_permission_check"></a><code>pm_permission_check</code></h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">st=&gt;start: pm_permission_check</span><br><span class="line">e=&gt;end: return DECLINED</span><br><span class="line">mconf=&gt;operation: mconf = ap_get_module_config(server-&gt;module_config, &amp;pmc_module);</span><br><span class="line">dconf=&gt;operation: dconf = ap_get_module_config(r-&gt;per_dir_config, &amp;pmc_module);</span><br><span class="line">ret=&gt;operation: ret</span><br><span class="line">finish_check=&gt;operation: finish_check</span><br><span class="line">curl=&gt;operation: curl_handle = curl_easy_init();</span><br><span class="line">rconf=&gt;operation: rconf = pmc_create_request_conf(r-&gt;pool);</span><br><span class="line">mconf_service_provider=&gt;operation: mconf-&gt;service_provider//检测服务提供者</span><br><span class="line"></span><br><span class="line">mconf_enable=&gt;condition: mconf-&gt;enable</span><br><span class="line">dconf_skip=&gt;condition: dconf-&gt;skip</span><br><span class="line">mconf_service=&gt;condition: uri == NULL</span><br><span class="line">mconf_control_type=&gt;condition: mconf-&gt;control_type == CT_CONNECT</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">st-&gt;mconf-&gt;mconf_enable</span><br><span class="line">mconf_enable(no, bottom)-&gt;dconf</span><br><span class="line">mconf_enable(yes)-&gt;ret</span><br><span class="line">dconf-&gt;dconf_skip</span><br><span class="line">dconf_skip(yes)-&gt;e</span><br><span class="line">dconf_skip(no, bottom)-&gt;mconf_service</span><br><span class="line">mconf_service(yes)-&gt;e</span><br><span class="line">mconf_service(no, bottom)-&gt;curl</span><br><span class="line">curl-&gt;rconf</span><br><span class="line">rconf-&gt;mconf_control_type</span><br><span class="line">mconf_control_type(yes)-&gt;finish_check</span><br><span class="line">mconf_control_type(no, bottom)-&gt;mconf_service_provider</span><br></pre></td></tr></table></figure>
<p>浩浩荡荡画了这么长flowchar，我决定放弃了，开始是画图比读代码容易理解，此刻画图却成了折磨，还是读代码爽啊。</p>
<p>检查服务提供者算是第一道比较重要的关卡，<code>mconf-&gt;service_provider</code>有三种可能的值：</p>
<ul>
<li><p>SP_LOCAL:</p>
<p>check_permission_with_local(r, mconf)</p>
</li>
<li><p>SP_MTSMS:</p>
<p>check_permission_with_mtsms(r, mconf, curl_handler, new_url)</p>
</li>
<li><p>SP_TJJMS:</p>
<p>mconf-&gt;control_type</p>
<ul>
<li><p>CT_CONNECT</p>
<p>check_permission_with_tjjms(r, mconf, curl_handle, new_url)</p>
</li>
<li><p>CT_ACCESS</p>
</li>
</ul>
</li>
</ul>

          
        
      
    </div>

    

    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://renzheng0403.github.io/2017/09/10/2017-09-10-量子与通信/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="renzheng">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="renz">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2017/09/10/2017-09-10-量子与通信/" itemprop="url">
                  量子与通信
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">

            
            
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              

              
                
              

              <time title="创建时间：2017-09-10 20:50:00" itemprop="dateCreated datePublished" datetime="2017-09-10T20:50:00+08:00">2017-09-10</time>
            

            
              

              
                
                <span class="post-meta-divider">|</span>
                

                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                
                  <span class="post-meta-item-text">更新于</span>
                
                <time title="修改时间：2018-06-24 23:32:06" itemprop="dateModified" datetime="2018-06-24T23:32:06+08:00">2018-06-24</time>
              
            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>前言</p>
<blockquote>
<p>昨天抽空看了一下公司里的一份培训资料——《量子计算和量子通信》，突然觉得自己可能确实正处于某项新技术的萌芽状态。比如Internet最开始也不过是实验室里的小范围产物而已，研究者们认为它可能会方便交流，但是当时的人们也许只会想，这东西能有什么用呢？</p>
<p>再早一点，法拉第演示电磁感应的时候不也是遇到了同样的疑问吗？而现如今也有一种技术，它的理论已经被提出，目前还是实验室的产物，会被人问这东西有什么用，我觉得应该就是量子计算了。遗憾的是，天才发明的东西太难理解，将再一次被科技远远甩开。</p>
<p>当年自己《量子物理》当年可耻的挂了，从此开始了<strong>可耻纪元</strong>。高等数学-&gt;复变函数-&gt;量子物理，这些是了解量子计算和量子通信的基本工具，虽然很不情愿，但为了量子计算机，也只能硬着头皮去学了，被时代抛弃真的是很不情愿。<br>下面的内容都是毫无头脑的简单积累，不涉及科学系统学习。</p>
</blockquote>
<h1 id="量子力学基础"><a href="#量子力学基础" class="headerlink" title="量子力学基础"></a>量子力学基础</h1><h2 id="量子态的叠加（干涉）性"><a href="#量子态的叠加（干涉）性" class="headerlink" title="量子态的叠加（干涉）性"></a>量子态的叠加（干涉）性</h2><h2 id="量子纠缠性"><a href="#量子纠缠性" class="headerlink" title="量子纠缠性"></a>量子纠缠性</h2><h2 id="量子不可克隆性定理"><a href="#量子不可克隆性定理" class="headerlink" title="量子不可克隆性定理"></a>量子不可克隆性定理</h2><h2 id="量子不确定性原理"><a href="#量子不确定性原理" class="headerlink" title="量子不确定性原理"></a>量子不确定性原理</h2><h1 id="量子计算"><a href="#量子计算" class="headerlink" title="量子计算"></a>量子计算</h1><h2 id="shor算法"><a href="#shor算法" class="headerlink" title="shor算法"></a>shor算法</h2><h2 id="Grover算法"><a href="#Grover算法" class="headerlink" title="Grover算法"></a>Grover算法</h2><h1 id="量子密钥分发（QKD）"><a href="#量子密钥分发（QKD）" class="headerlink" title="量子密钥分发（QKD）"></a>量子密钥分发（QKD）</h1><h2 id="BB84协议"><a href="#BB84协议" class="headerlink" title="BB84协议"></a>BB84协议</h2><h2 id="E91协议"><a href="#E91协议" class="headerlink" title="E91协议"></a>E91协议</h2><h2 id="附"><a href="#附" class="headerlink" title="附"></a>附</h2><p>Quantum Secret Sharing<br>Quantum Coin Tossing<br>Quantum Bit Commitment<br>Quantum Public-Key Cryptosystem</p>
<h1 id="课外阅读"><a href="#课外阅读" class="headerlink" title="课外阅读"></a>课外阅读</h1><p><a href="http://peterhs.blog.51cto.com/6318839/1104560" target="_blank" rel="noopener">量子计算机编程原理简介 和 机器学习</a></p>
<p><a href="http://open.163.com/special/cuvocw/liangzijishu.html" target="_blank" rel="noopener">中国科学技术大学公开课：来自量子世界的新技术</a></p>
<p><a href="http://blog.csdn.net/column/details/16030.html" target="_blank" rel="noopener">量子力学及量子计算</a></p>
<p><a href="https://zhuanlan.zhihu.com/p/22306837" target="_blank" rel="noopener">从量子力学到量子卫星：如何在量子科学领域谈笑风生|袁岚峰</a></p>
<p><a href="http://www.quantum-comm.com/index.html" target="_blank" rel="noopener">国盾量子</a></p>
<p><a href="http://www.qasky.com/" target="_blank" rel="noopener">问天量子</a></p>

          
        
      
    </div>

    

    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://renzheng0403.github.io/2017/09/09/2017-09-09-SSL-and-TLS-知识点/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="renzheng">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="renz">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2017/09/09/2017-09-09-SSL-and-TLS-知识点/" itemprop="url">
                  SSL and TLS 知识点
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">

            
            
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              

              
                
              

              <time title="创建时间：2017-09-09 00:00:00" itemprop="dateCreated datePublished" datetime="2017-09-09T00:00:00+08:00">2017-09-09</time>
            

            
              

              
                
                <span class="post-meta-divider">|</span>
                

                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                
                  <span class="post-meta-item-text">更新于</span>
                
                <time title="修改时间：2018-06-24 23:18:40" itemprop="dateModified" datetime="2018-06-24T23:18:40+08:00">2018-06-24</time>
              
            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/SSL/" itemprop="url" rel="index"><span itemprop="name">SSL</span></a></span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>TLS四个核心主协议：</p>
<ul>
<li>handshake protocol 握手协议</li>
<li>change cipher spec protocol 密钥规格变更协议</li>
<li>application data protocol 应用数据协议</li>
<li><p>alert protocol 警报协议</p>
</li>
<li><p>record协议：包括对消息的分段、压缩、消息认证和完整性保护、加密</p>
</li>
</ul>
<p>SSL核心功能：握手、密钥交换、相互认证、保密数据传输</p>
<p>SSL握手的三个目的：</p>
<ul>
<li>客户端与服务器就一组保护数据的算法达成一致</li>
<li>确立一组由算法使用的密钥</li>
<li>还可以选择对客户端身份进行认证</li>
</ul>
<p>由于SSL/TLS协议自身特性（数字证书），不能被用于保护多跳端到端通信，只能保护点到点通信。</p>
<p>SSL/TLS协议能够提供的安全目标：</p>
<ul>
<li>身份认证（数字证书）</li>
<li>机密传输（信息加密）</li>
<li>数据完整性（MAC）</li>
<li>重放保护（通过使用隐式序列号防止重放攻击）</li>
</ul>
<h1 id="SSL总体流程"><a href="#SSL总体流程" class="headerlink" title="SSL总体流程"></a>SSL总体流程</h1><p><img src="/images/SSL握手概述.png" alt="SSL握手概述"></p>
<ol>
<li>客户端将其支持的算法列表和一个用作密钥生成算法输入的随机数发送给服务器</li>
<li>服务器选择一个加密算法，并将其和包含服务器公钥的证书发送给客户端，还包括一个用作密钥生成算法输入的随机数</li>
<li>客户端验证服务器证书，并抽取服务器公钥。同时生成一个pre_master_secret随即密码串，然后使用服务器公钥对其进行加密，将加密的信息发送给服务器</li>
<li>客户端和服务器根据pre_master_secret和随机数值独立计算加密密钥和MAC密钥</li>
<li>客户端将所有握手消息MAC值加密后发送给服务器</li>
<li>服务器将所有握手消息MAC值加密后发送给客户端</li>
</ol>
<h1 id="SSL连接"><a href="#SSL连接" class="headerlink" title="SSL连接"></a>SSL连接</h1><p><img src="/images/SSL连接.png" alt="SSL连接"></p>
<ol>
<li>握手消息ClientHello，用于告知服务器客服端所支持的密码套件种类、最高SSL/TLS协议版本以及压缩算法。还包括一个客户端生成的用于密钥产生的随机数，在密钥生成过程中被使用（其它有Session值，第一次握手为0；版本号）</li>
<li>服务器返回的一系列握手消息。首先是ServerHello，包含了服务器选择的加密参数。还包括一个服务器生成的用于密钥产生的随机数，如果是第一次握手，服务器将提供给客户端一个Session值用于恢复使用已经协商好的密钥信息</li>
<li>服务器发送Certificate，该消息是X.509证书序列，证书依序提供，从服务器证书开始，到Certificate authority或者最新的自签名证书结束。同时证书会附带携带与协商的密钥交换算法对应的密钥。客户端除了校验签名信息，还要保证证书链中的所有证书均未被吊销。</li>
<li>ServerHelloDone，表示服务器已发送在此阶段要发送的全部信息。此项告诉客户端本次Certificate后面没有可选信息，不用再等了</li>
<li>ClientKeyExchange客户端验证了服务端证书并并抽取公钥后，使用服务器公钥对生成的被称为pre_master_secret的随机密钥串加密，再通过此消息发送</li>
<li>ChangeCipherSpec告诉服务器，客户端之后的消息都是用商定的加密算法，此消息不属于握手消息，</li>
<li>Finished 发送前一阶段的所有握手消息MAC值，对握手消息校验，这样服务器可以判断使用的加密算法是否是安全商定的，而没有遭到中间人篡改或诱导</li>
<li>ChangeCipherSpec告诉客户端，服务器之后的消息都使用商定的加密算法</li>
<li>Finished</li>
</ol>
<h2 id="ClientHello"><a href="#ClientHello" class="headerlink" title="ClientHello"></a>ClientHello</h2><p>结构体：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">struct &#123;</span><br><span class="line"> ProtocolVersion client_version;</span><br><span class="line"> Random random;</span><br><span class="line"> SessionlD session_id; </span><br><span class="line">  CipherSuite cipher_suites&lt;2..2^16-1&gt;;</span><br><span class="line"> CompressionMethod compression_methods&lt;l..2^8-1&gt;;</span><br><span class="line">&#125; ClientHello;</span><br><span class="line"></span><br><span class="line">struct &#123;</span><br><span class="line"> uint8 major;</span><br><span class="line"> uint8 minor;</span><br><span class="line">&#125; ProtocolVersion;</span><br><span class="line"></span><br><span class="line">struct &#123;</span><br><span class="line"> uint32 gmt_unix_time;</span><br><span class="line"> opaque random_bytes[28];</span><br><span class="line">&#125; Random;</span><br><span class="line"></span><br><span class="line">opaque SessionlD&lt;0..32&gt;;</span><br><span class="line">uint8 CipherSuite[2];</span><br><span class="line">enum &#123;null(0),(255)&#125; CompressionMethod;</span><br></pre></td></tr></table></figure></p>
<p>消息：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line">Handshake Protocol: Client Hello</span><br><span class="line">    Handshake Type: Client Hello (1)</span><br><span class="line">    Version: TLS 1.2 (0x0303)</span><br><span class="line">    Random</span><br><span class="line">        GMT Unix Time: Apr 13, 2053 09:32:30.000000000 �й���׼ʱ��</span><br><span class="line">        Random Bytes: b383297830cf9a3e82ddd7152edff8f6d015fbd697f3a5d8...</span><br><span class="line">    Session ID: d8ae81d62bd18b0cc3f1e7b8774bdd2b1e4755419ab1058e...</span><br><span class="line">    Cipher Suites (14 suites)</span><br><span class="line">        Cipher Suite: TLS_ECDHE_ECDSA_WITH_AES_128_GCM_SHA256 (0xc02b)</span><br><span class="line">        Cipher Suite: TLS_ECDHE_RSA_WITH_AES_128_GCM_SHA256 (0xc02f)</span><br><span class="line">        Cipher Suite: TLS_ECDHE_ECDSA_WITH_AES_256_GCM_SHA384 (0xc02c)</span><br><span class="line">        Cipher Suite: TLS_ECDHE_RSA_WITH_AES_256_GCM_SHA384 (0xc030)</span><br><span class="line">        Cipher Suite: TLS_ECDHE_RSA_WITH_AES_128_CBC_SHA (0xc013)</span><br><span class="line">        Cipher Suite: TLS_ECDHE_RSA_WITH_AES_256_CBC_SHA (0xc014)</span><br><span class="line">        Cipher Suite: TLS_RSA_WITH_AES_128_GCM_SHA256 (0x009c)</span><br><span class="line">        Cipher Suite: TLS_RSA_WITH_AES_256_GCM_SHA384 (0x009d)</span><br><span class="line">        Cipher Suite: TLS_RSA_WITH_AES_128_CBC_SHA (0x002f)</span><br><span class="line">        Cipher Suite: TLS_RSA_WITH_AES_256_CBC_SHA (0x0035)</span><br><span class="line">        Cipher Suite: TLS_RSA_WITH_3DES_EDE_CBC_SHA (0x000a)</span><br><span class="line">    Compression Methods (1 method)</span><br><span class="line">        Compression Method: null (0)</span><br><span class="line">    Extensions Length: 407</span><br><span class="line">    Extension: renegotiation_info</span><br><span class="line">        Renegotiation Info extension</span><br><span class="line">            Renegotiation info extension length: 0</span><br><span class="line">    Extension: server_name</span><br><span class="line">        Server Name Indication extension</span><br><span class="line">            Server Name: www.baidu.com</span><br><span class="line">    Extension: signature_algorithms</span><br><span class="line">        Signature Hash Algorithms (9 algorithms)</span><br><span class="line">            Signature Hash Algorithm: 0x0403</span><br><span class="line">                Signature Hash Algorithm Hash: SHA256 (4)</span><br><span class="line">                Signature Hash Algorithm Signature: ECDSA (3)</span><br><span class="line">            Signature Hash Algorithm: 0x0401</span><br><span class="line">                Signature Hash Algorithm Hash: SHA256 (4)</span><br><span class="line">                Signature Hash Algorithm Signature: RSA (1)</span><br><span class="line">            </span><br><span class="line">    Extension: elliptic_curves</span><br><span class="line">        Elliptic curves (4 curves)</span><br><span class="line">            Elliptic curve: Unknown (0xaaaa)</span><br><span class="line">            Elliptic curve: Unknown (0x001d)</span><br><span class="line">            Elliptic curve: secp256r1 (0x0017)</span><br><span class="line">            Elliptic curve: secp384r1 (0x0018)</span><br></pre></td></tr></table></figure></p>
<p>客户端在新建连接后，希望重新协商或者响应服务器发起的重新协商请求时，发送这条消息。该消息将客户端的功能和首选项传送给服务器，包含以下关键元素：</p>
<ul>
<li>Version 协议版本，包含客户端准备接受的最高SSL版本号</li>
<li>Random 握手时客户端与服务器都会提供随机数，用于身份验证，可以防止重放攻击（<strong>但是为什么</strong>）<ul>
<li>Client time（4byte)产生消息时的时间</li>
<li>Random bytes（28byte）随机生成，确保即使使用同一个pre_master_secret</li>
</ul>
</li>
<li>Session ID客户端用来指示希望重复使用前一次连接是的加密密钥资料</li>
<li>Ciper Suites 密码套件，指定服务器的认证算法、密钥交换算法、批量加密算法和摘要算法（消息完整性）。可参考(ssl握手协议中的CipherSuite)[<a href="http://blog.csdn.net/dog250/article/details/5750992]" target="_blank" rel="noopener">http://blog.csdn.net/dog250/article/details/5750992]</a> ，baidu一篇正好是公司前辈的文章</li>
<li>Compression Methods 客户端可以提交一个或多个支持压缩的方法。默认的压缩方法是null</li>
<li>Extensions 扩展额外数据</li>
</ul>
<h2 id="ServerHello"><a href="#ServerHello" class="headerlink" title="ServerHello"></a>ServerHello</h2><p>将服务器选择的连接参数传回客户端<br>结构与ClientHello类似：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">Handshake Protocol: Server Hello</span><br><span class="line">    Version: TLS 1.2 (0x0303)</span><br><span class="line">    Random</span><br><span class="line">        GMT Unix Time: Sep  9, 2017 14:38:09.000000000 �й���׼ʱ��</span><br><span class="line">        Random Bytes: d3fe2fbdbbe626fc09b691158652d6808239d05b7b9ed0a3...</span><br><span class="line">    Session ID: d8ae81d62bd18b0cc3f1e7b8774bdd2b1e4755419ab1058e...</span><br><span class="line">    Cipher Suite: TLS_ECDHE_RSA_WITH_AES_128_GCM_SHA256 (0xc02f)</span><br><span class="line">    Compression Method: null (0)</span><br><span class="line">    Extension: Application Layer Protocol Negotiation</span><br><span class="line">        ALPN Protocol</span><br><span class="line">            ALPN Next Protocol: http/1.1</span><br></pre></td></tr></table></figure></p>
<p>服务器也提供了一个随机值，用它连同客户端提供的随机值，以及pre_master_secret一起产生密钥资料。</p>
<h2 id="Certificate"><a href="#Certificate" class="headerlink" title="Certificate"></a>Certificate</h2><p>X.509证书序列</p>
<h2 id="ServerHelloDone"><a href="#ServerHelloDone" class="headerlink" title="ServerHelloDone"></a>ServerHelloDone</h2><p>是一条空消息，表明服务器已经发送了在此阶段要发送的全部消息</p>
<h2 id="ClientKeyExchange"><a href="#ClientKeyExchange" class="headerlink" title="ClientKeyExchange"></a>ClientKeyExchange</h2><p>携带客户端为密钥交换提供的所有信息<br>结构体：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">struct &#123;</span><br><span class="line"> select (KeyExchangeAIgorithm) &#123;</span><br><span class="line"> case rsa: EncryptedPreMasterSecret;</span><br><span class="line"> case diffie_hellman: DiffieHellmanClientPublicValue;</span><br><span class="line"> &#125; exchange_keys;</span><br><span class="line">&#125; ClientKeyExchange;</span><br><span class="line">struct &#123;</span><br><span class="line"> ProtocolVersion client_version;</span><br><span class="line"> opaque random[46];</span><br><span class="line">&#125; PreMasterSecret;</span><br><span class="line">struct &#123;</span><br><span class="line"> public-key-encrypted PreMasterSecret pre_master_secret;</span><br><span class="line">&#125; EncryptedPreMasterSecret;</span><br><span class="line">enum &#123; implicit, explicit &#125; PublicValueEncoding;</span><br><span class="line">struct &#123;</span><br><span class="line"> select (PublicValueEncoding) &#123;</span><br><span class="line"> case implicit: struct &#123;&#125;;</span><br><span class="line"> case explicit: opaque DH_Yc&lt;I..2^16-1 &gt;;</span><br><span class="line"> &#125; dh_public;</span><br><span class="line">&#125; DiffieHellmanClientPublicValue;</span><br></pre></td></tr></table></figure></p>
<h2 id="ChangeCipherSpec（不属于握手消息）"><a href="#ChangeCipherSpec（不属于握手消息）" class="headerlink" title="ChangeCipherSpec（不属于握手消息）"></a>ChangeCipherSpec（不属于握手消息）</h2><p>指示发送实现已经切换好的算法和密钥资料，之后发送的消息将使用算法加以保护</p>
<h2 id="Finished"><a href="#Finished" class="headerlink" title="Finished"></a>Finished</h2><p>结构体：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">SSLv3:</span><br><span class="line">struct &#123;</span><br><span class="line"> opaque md5_hash[16];</span><br><span class="line"> opaque sha_hash[20];</span><br><span class="line">&#125;Finished;</span><br><span class="line">TLS:</span><br><span class="line">struct &#123;</span><br><span class="line"> opaque verify_data[12];</span><br><span class="line">&#125; Finished;</span><br></pre></td></tr></table></figure></p>
<p>每一方向另一方发送协商后的主密码与连结起来的握手消息的摘要信息，另一方将其与本地计算得出的摘要对比。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">md5_hash = MD5(master_secret + pad2 + MD5(handshake_messages + Sender + master_secret + pad1) );</span><br></pre></td></tr></table></figure>
<p>第一遍调用MD5的输入：所有握手消息、Sender常量、master_secret、填充字节（pad1为字节0x36重复48次所形成的字符串）</p>
<p>第二遍调用MD5的输入：主密码、填充字节（pad2为字节0x5c重复48次所形成的字符串）、第一遍的输出</p>
<p>Finished另一个有趣的地点在于第二个发送Finished的一方将前一个Finished的消息计算在摘要值之内的可能性，如下图所示：<br><img src="/images/SSL-handshark-Finished.png" alt="Finished"><br>这样当服务器计算握手消息的时候会多计算两个握手消息，必然不会匹配。解决的办法是在处理Finished消息之前再创建一份摘要对象的拷贝。</p>
<h1 id="SSL记录协议"><a href="#SSL记录协议" class="headerlink" title="SSL记录协议"></a>SSL记录协议</h1><p><img src="/images/SSL记录层.png" alt="SSL记录层协议"></p>
<p>SSL记录层协议将数据流分割成片段加密传输</p>
<p>记录头包含三种信息：内容类型、长度、SSL版本</p>
<p>结构体：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">struct &#123;</span><br><span class="line"> ContentType type;</span><br><span class="line"> ProtocolVersion version;</span><br><span class="line"> uint16 length;</span><br><span class="line">&#125; RecordHeader;</span><br><span class="line">enum &#123;</span><br><span class="line"> change_cipher_spec(20), alert(21), handshake(22),</span><br><span class="line"> application_data(23), (255)</span><br><span class="line">&#125; ContentType;</span><br><span class="line">struct &#123;</span><br><span class="line"> uint8 major;</span><br><span class="line"> uint8 minor;</span><br><span class="line">&#125; ProtocolVersion;</span><br></pre></td></tr></table></figure></p>
<h2 id="内容类型"><a href="#内容类型" class="headerlink" title="内容类型"></a>内容类型</h2><p>SSL支持四种内容类型：application_data、alert、handshark、change_cipher_spec</p>
<p>alert用于报告各种类型的错误</p>
<p>handshark用于承载握手信息</p>
<p>change_cipher_spec表示加密及认证的改变，指示使用新的密钥</p>
<h2 id="长度"><a href="#长度" class="headerlink" title="长度"></a>长度</h2><p>让接收方知道要从线路上读取多少字节消息</p>
<h2 id="版本号"><a href="#版本号" class="headerlink" title="版本号"></a>版本号</h2><h1 id="会话恢复"><a href="#会话恢复" class="headerlink" title="会话恢复"></a>会话恢复</h1><p>先看与百度的握手过程：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">459	22.284378	192.168.41.110	115.239.211.112	TLSv1.2	571	Client Hello</span><br><span class="line">461	22.294188	115.239.211.112	192.168.41.110	TLSv1.2	150	Server Hello</span><br><span class="line">462	22.294210	115.239.211.112	192.168.41.110	TLSv1.2	60	Change Cipher Spec</span><br><span class="line">464	22.295709	115.239.211.112	192.168.41.110	TLSv1.2	99	Hello Request, Hello Request</span><br><span class="line">465	22.295942	192.168.41.110	115.239.211.112	TLSv1.2	105	Change Cipher Spec, Hello Request, Hello Request</span><br><span class="line">468	22.299020	192.168.41.110	115.239.211.112	TLSv1.2	82	Application Data</span><br><span class="line">...</span><br></pre></td></tr></table></figure></p>
<p>这里由于ClientHello提供了一个Session，使用了前一次SSL握手协商好的加密密钥信息，因此当客户端接收到ServerHello后就发送ChangeCipherSpec通知服务端后面的消息将使用之前的加密密钥加密</p>
<p>可以发现省略了Certificate，ClientKeyExchange，并不涉及到密钥及加密算法交换等信息，而且此后的消息都是通过加密密钥发送的，如果攻击者冒充服务端，自然无法解开收到的消息，这解释了为什么客户端没有验证服务端身份。</p>
<p>恢复SSL会话流程：<br><img src="/images/SSL-Session.png" alt="SSL-Session"></p>
<h1 id="客户端身份验证"><a href="#客户端身份验证" class="headerlink" title="客户端身份验证"></a>客户端身份验证</h1><p>服务器通过发送CertificateRequest消息请求对客户端进行身份验证，客户端接受后发送自己的Certificate消息，再发送CertificateVerify消息证明自己拥有对应的私钥。</p>
<p>服务器将告诉客户端，我接受哪些证书和签名算法，或者接受哪些证书颁发机构：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">struct &#123;</span><br><span class="line">    ClientCertificateType certificate_types;</span><br><span class="line">    SignatureAndHashAlgorithm supported_signature_algorithms;</span><br><span class="line">    DistinguishedName certificate_authorities;</span><br><span class="line">&#125; CertificateRequest;</span><br><span class="line">enum&#123;</span><br><span class="line"> rsa_sign(1),dss_sign(2),rsa_fixed_dh(3),dss_fixed_dh(4),</span><br><span class="line"> (255)</span><br><span class="line">&#125;ClientCertificateType;</span><br><span class="line">opaque DistinguishedName&lt;l..2^16-1&gt;;</span><br></pre></td></tr></table></figure></p>
<p>客户端将发送一条到这一步为止的所有握手消息的签名，以此证明自己拥有的私钥与之前发送的客户端证书中的公钥匹配：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">struct &#123;</span><br><span class="line">    Signature handshark_message_signature;</span><br><span class="line">&#125; CertificateVerify;</span><br></pre></td></tr></table></figure></p>
<p>若是你对我的私钥与证书中CA机构确认的公钥有怀疑，可以自己进行计算签名值对比（我觉得一定会的）</p>
<h1 id="临时RSA"><a href="#临时RSA" class="headerlink" title="临时RSA"></a>临时RSA</h1><p>ServerKeyExchange（在ServerHelloDone之前）服务器使用该消息传输经过签名的512bit RSA密钥，客户端收到该消息后，验证临时密钥上的服务器签名，并使用其加密pre_master_secret</p>
<h1 id="再握手（Rehandshake）"><a href="#再握手（Rehandshake）" class="headerlink" title="再握手（Rehandshake）"></a>再握手（Rehandshake）</h1><p>建立SSL连接之后再进行一次握手，客户端发送一条ClientHello，如果服务器同意，发送空的HelloRequest握手消息，客户端发送ClientHello作为响应。如果服务器不同意，发送一条no_renegotiation警示。</p>
<h1 id="密钥交换算法的区别"><a href="#密钥交换算法的区别" class="headerlink" title="密钥交换算法的区别"></a>密钥交换算法的区别</h1><p>密钥交换的目的是计算<strong>预主密钥</strong>（premaster secret），这个值是组成<strong>主密钥</strong>（master secret）的来源。</p>
<h2 id="TLS-RSA"><a href="#TLS-RSA" class="headerlink" title="TLS-RSA"></a>TLS-RSA</h2><p>PreMasterSecret由客户端指定，并用RSA公钥加密发送给服务器。</p>
<h2 id="TLS-DH"><a href="#TLS-DH" class="headerlink" title="TLS-DH"></a>TLS-DH</h2><p>双方各自提交一个证书包含DH公开值，服务器端提交证书包含DH公开值。</p>
<h2 id="TLS-DHE"><a href="#TLS-DHE" class="headerlink" title="TLS-DHE"></a>TLS-DHE</h2><p>基于DHE的TLS握手中有ServerKeyExchange消息。DH参数和它的数字签名均被包含在消息中，握手过程中交换参数的认证就是通过数字签名实现，支持的签名算法包括RSA和DSS。</p>
<h2 id="附：Diffie-Hellman密钥交换"><a href="#附：Diffie-Hellman密钥交换" class="headerlink" title="附：Diffie-Hellman密钥交换"></a>附：Diffie-Hellman密钥交换</h2><p>抛开算法的细节（因为我不懂），DH密钥交换需要6个参数：</p>
<ul>
<li>域参数（服务器选取）<ul>
<li>dh_p</li>
<li>dh_g</li>
</ul>
</li>
<li>客户端<ul>
<li>dh_Ys</li>
<li>dh_Yc</li>
</ul>
</li>
<li>服务器<ul>
<li>dh_Ys</li>
<li>dh_Yc</li>
</ul>
</li>
</ul>
<p>协商过程中客户端和服务器相互发送其中一个参数（dh_Ys和dh_Yc）到对端</p>
<p>服务器发送ServerDHparams:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">struct &#123;</span><br><span class="line">    opaque dh_p;</span><br><span class="line">    opaque dh_g;</span><br><span class="line">    opaque dh_Ys;</span><br><span class="line">&#125; ServerDHParams;</span><br></pre></td></tr></table></figure></p>
<p>客户端相应并发送其公开参数（dh_Yc）:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">struct &#123;</span><br><span class="line">    select (PublicValueEncoding) &#123;</span><br><span class="line">        case implicit:</span><br><span class="line">        case explicit:</span><br><span class="line">            opaque dh_Yc;</span><br><span class="line">    &#125; dh_public;</span><br><span class="line">&#125;ClientDiffHellmanPublic;</span><br></pre></td></tr></table></figure></p>
<h1 id="密钥生成"><a href="#密钥生成" class="headerlink" title="密钥生成"></a>密钥生成</h1><p>Pseudo-random Function（PRF，伪随机函数）：秘密值扩展、密钥生成</p>
<p>工作原理如图<br><img src="/images/PRF.png" alt=""><br>PRF基于两个hash函数：MD5和SHA-1；</p>
<p>有三个输入：</p>
<ul>
<li>Secret，例如PreMasterSecret，在使用时被分为长度相同的两半：S1和S2，跟别作为P_MD5和P_SHA-1的输入。</li>
<li>Label标志服</li>
<li>Seed种子值（客户端随机数+服务器随机数）</li>
</ul>
<p>SSL/TLS协议密钥的生成过程：<br><img src="/images/SSL-key.png" alt=""></p>

          
        
      
    </div>

    

    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://renzheng0403.github.io/2017/09/07/2017-09-07-markdown-flow/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="renzheng">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="renz">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2017/09/07/2017-09-07-markdown-flow/" itemprop="url">
                  markdown flow
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">

            
            
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              

              
                
              

              <time title="创建时间：2017-09-07 00:00:00" itemprop="dateCreated datePublished" datetime="2017-09-07T00:00:00+08:00">2017-09-07</time>
            

            
              

              
                
                <span class="post-meta-divider">|</span>
                

                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                
                  <span class="post-meta-item-text">更新于</span>
                
                <time title="修改时间：2018-06-24 23:25:08" itemprop="dateModified" datetime="2018-06-24T23:25:08+08:00">2018-06-24</time>
              
            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/前端/" itemprop="url" rel="index"><span itemprop="name">前端</span></a></span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="flowchart"><a href="#flowchart" class="headerlink" title="flowchart"></a>flowchart</h1><p>流程图语法分为两部分：</p>
<ul>
<li>定义流程图元素</li>
<li>定义流程图的执行走向（用来连接流程图元素）</li>
</ul>
<h2 id="定义元素"><a href="#定义元素" class="headerlink" title="定义元素"></a>定义元素</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tag=&gt;type: content</span><br></pre></td></tr></table></figure>
<h3 id="说明"><a href="#说明" class="headerlink" title="说明"></a>说明</h3><ul>
<li><strong>tag</strong>流程图的标签，用来在定义执行走向的时候指定下一步到达何处，可理解为<strong>名字</strong></li>
<li><strong>type</strong>确定标签类型，表示这个标签的种类是开始结束，输入输出还是判断等</li>
<li><strong>content</strong>流程图文本框内的描述内容</li>
</ul>
<h3 id="标签类型"><a href="#标签类型" class="headerlink" title="标签类型"></a>标签类型</h3><ul>
<li><code>start</code>：开始<code>st=&gt;start: 开始</code></li>
<li><code>end</code>：结束<code>e=&gt;end: 结束</code></li>
<li><code>operation</code>：操作、步骤、执行说明<code>op1=&gt;operation: come to eat</code></li>
<li><code>subroutine</code>：子步骤<code>sb1=&gt;subroutine: go back</code></li>
<li><code>condition</code>：条件选择<code>cond=&gt;condition: is it rain?</code></li>
<li><code>inputoutput</code>：输入输出</li>
</ul>
<h2 id="定义执行走向"><a href="#定义执行走向" class="headerlink" title="定义执行走向"></a>定义执行走向</h2><ul>
<li>使用<code>-&gt;</code>连接两个元素(标签)</li>
<li>对于<code>condition</code>类型，有<code>cond(yes)</code>和<code>cond(no)</code>两种控制走向的语法</li>
<li>其他元素也可以控制分支方向，默认<code>向下</code>，使用<code>right</code>向右，例<code>sb1(right)</code></li>
</ul>
<h2 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">st=&gt;start: Home</span><br><span class="line">e=&gt;end: Restaurant</span><br><span class="line">op1=&gt;operation: get out to eat</span><br><span class="line">cond=&gt;condition: is it rain?</span><br><span class="line">sb1=&gt;subroutine: go back and try again</span><br><span class="line">op2=&gt;operation: arrive</span><br><span class="line">st-&gt;op1-&gt;cond</span><br><span class="line">cond(yes)-&gt;op2-&gt;e</span><br><span class="line">cond(no)-&gt;sb1(right)-&gt;op1</span><br></pre></td></tr></table></figure>
<p><img src="/images/example-flowchart.png" alt="flowchart"></p>
<h1 id="sequence"><a href="#sequence" class="headerlink" title="sequence"></a>sequence</h1><p>sequence语法仅一种格式，即A到B的路径，外加可控制的note</p>
<h2 id="定义元素-1"><a href="#定义元素-1" class="headerlink" title="定义元素"></a>定义元素</h2><p><img src="/images/sequence-grammar.png" alt="sequence grammar"></p>
<h3 id="说明-1"><a href="#说明-1" class="headerlink" title="说明"></a>说明</h3><ul>
<li>路径：包含两种线型和两种箭头，共四种组合方式</li>
<li><strong>note</strong>：旁注</li>
</ul>
<h2 id="实例-1"><a href="#实例-1" class="headerlink" title="实例"></a>实例</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">Title: Here is a title</span><br><span class="line">A-&gt;B: Normal line</span><br><span class="line">B--&gt;C: Dashed line</span><br><span class="line">C-&gt;&gt;D: Open arrow</span><br><span class="line">D--&gt;&gt;A: Dashed open arrow</span><br><span class="line">Note left of A: Note to the\n left of A</span><br><span class="line">Note right of A: Note to the\n right of A</span><br><span class="line">Note over A: Note over A</span><br><span class="line">Note over A,B: Note over both A and B</span><br></pre></td></tr></table></figure>
<p><img src="/images/example-sequence.PNG" alt="js sequence diagrams"></p>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://bramp.github.io/js-sequence-diagrams/" target="_blank" rel="noopener">js-sequence-diagrams/Turns text into UML sequence diagrams</a></p>
<h1 id="附"><a href="#附" class="headerlink" title="附"></a>附</h1><p>未完待续，后面还会介绍mathjax用法，这个在这个模板里直接就可以使用，而以上两个属性暂时还不支持，应该是和js调用有关，太麻烦，我只是想使用，便于展示总结，所以暂时使用截图</p>

          
        
      
    </div>

    

    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://renzheng0403.github.io/2017/08/26/2017-08-26-PKI知识点总结/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="renzheng">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="renz">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2017/08/26/2017-08-26-PKI知识点总结/" itemprop="url">
                  网关服务端第一阶段总结
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">

            
            
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              

              
                
              

              <time title="创建时间：2017-08-26 00:00:00" itemprop="dateCreated datePublished" datetime="2017-08-26T00:00:00+08:00">2017-08-26</time>
            

            
              

              
                
                <span class="post-meta-divider">|</span>
                

                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                
                  <span class="post-meta-item-text">更新于</span>
                
                <time title="修改时间：2018-06-24 23:22:25" itemprop="dateModified" datetime="2018-06-24T23:22:25+08:00">2018-06-24</time>
              
            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/PKI/" itemprop="url" rel="index"><span itemprop="name">PKI</span></a></span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="算法"><a href="#算法" class="headerlink" title="算法"></a>算法</h1><h2 id="对称算法"><a href="#对称算法" class="headerlink" title="对称算法"></a>对称算法</h2><p>描述：对称加密是指加密过程和解密过程使用相同的密码。主要分：<strong>分组加密</strong>、<strong>序列加密</strong>。</p>
<p>原理：XOR运算，将二进制数据进行XOR运算，两次同样的操作得到原文，所以大致过程就是加密-&gt;A xor B = C，解密-&gt;C xor B = A（B就是密钥）。</p>
<p>优点：加密速度快，适合于对大量数据加密。</p>
<p>缺点：发送方和接受方需要使用相同的密钥，一旦密钥泄露，在互联网上传输的加密数据将会被中间人破解。而且由于加密数据量大</p>
<p>分类：</p>
<ul>
<li>DES(Data Encryption Standard)<ul>
<li>分组算法</li>
<li>分组长度64bit（8字节），明文分为左右两侧轮回与密钥XOR运算，每轮使用不同的密钥</li>
<li>密钥空间2^56</li>
</ul>
</li>
<li>三重DES(triple-DES),将DES重复3次<ul>
<li>分组长度64bit（8字节）</li>
</ul>
</li>
<li>AES(Advances Encryption Standard)，高级加密标准<ul>
<li>分组长度为128bit（16字节）</li>
<li>密钥长度只有128、192、256bit</li>
</ul>
</li>
<li>RC2,RC4,RC5<ul>
<li>RC2和RC5是分组算法，RC4是序列算法</li>
<li>RC5分组可变、密钥长度可变</li>
</ul>
</li>
<li>SSF33,SM1,SM4<ul>
<li>分组算法</li>
<li>分组长度128bit（16字节）</li>
</ul>
</li>
</ul>
<h2 id="摘要算法"><a href="#摘要算法" class="headerlink" title="摘要算法"></a>摘要算法</h2><p>摘要算法使用密码学hash函数，用于验证数据完整性（没有修改、插入、删除、或重放）。</p>
<p>输入数据的长度首先被填充为某固定长度分组的整数倍，填充的内容包括原始数据的位长度信息。安全性要求如下两种情况在计算上不可行（即没有攻击方法比穷举攻击更有效）：</p>
<ul>
<li>对预先指定的hash值找到对应的数据块（单向性）</li>
<li>找到两个不同的数据块对应相同的hash值（抗碰撞性）</li>
</ul>
<p>例如：Alice给Bob发了一条消息，Bob收到消息后，1）不能确定是不是Alice发的；2）不能确定消息是否被篡改。单向hash函数仍然不能解决问题1），但是可以解决问题2）。假如Bob能够从某种渠道获取这条消息的摘要值，那么只需在对收到的信息进行相同的hash计算，将结果与摘要值对比，若不同就说明消息遭到了篡改。</p>
<p>Hash算法一般是指Hash表的摘要算法，将不同的键值分散到不同的数组位置，允许少量的冲突碰撞</p>
<p>安全Hash算法（SHA）是使用最广泛的Hash函数</p>
<ul>
<li>MD2、MD4、MD5<ul>
<li>摘要长度128bit（16字节）</li>
</ul>
</li>
<li>SHA1、SHA2、SHA3<ul>
<li>Secure Hash Algorithm</li>
<li>SHA-1摘要长度160bit（20字节）</li>
<li>SHA-2摘要长度256bit（32byte)</li>
<li>SHA-3摘要长度384bit（48byte)</li>
</ul>
</li>
<li>SM3<ul>
<li>中国国家商用密码算法</li>
<li>摘要长度256bit（32byte）</li>
</ul>
</li>
</ul>
<p><a href="http://www.cnblogs.com/houkai/p/3486667.html" target="_blank" rel="noopener">摘要函数——MD2/MD4/MD5数字签名</a></p>
<h2 id="附1：消息认证码（MAC-Message-authentication-code）"><a href="#附1：消息认证码（MAC-Message-authentication-code）" class="headerlink" title="附1：消息认证码（MAC, Message authentication code）"></a>附1：消息认证码（MAC, Message authentication code）</h2><p>上节提到的摘要函数-单向散列函数只能识别消息是否完整，不能识别发送者的身份，消息认证码使用一种密钥相关联的单向散列函数，输入包括消息、密钥（发送者和接受者共享），输出固定长度的MAC值。</p>
<p>又称密码校验和，利用密钥<strong>K</strong>和可变长度的数据<strong>M</strong>生成固定长度的短数据块<strong>MAC</strong>，并将数据块附加在数据M之后：<br>$$<br>MAC = C(K, M)<br>$$<br>若对于数据的保密性要求不高（例如广播），可直接将消息<strong>M</strong>和<strong>MAC</strong>一起发给接受者，接收者收到后使用相同的密钥<strong>K</strong>和MAC函数<strong>C</strong>对消息<strong>M</strong>计算得出<strong>MAC2</strong>，再对比两者是否相等。（这里设定通信双方共享相同的密钥<strong>K</strong>）</p>
<p>若对于数据的保密性要求严格，可选择将消息<strong>M</strong>和<strong>MAC</strong>加密再发送：<br>$$<br>ENC = E(K_2, M||C(K_1,M))<br>$$<br>接收者收到数据后首先解密。</p>
<h2 id="附2：基于Hash函数的MAC：HMAC"><a href="#附2：基于Hash函数的MAC：HMAC" class="headerlink" title="附2：基于Hash函数的MAC：HMAC"></a>附2：基于Hash函数的MAC：HMAC</h2><p>HMAC将Hash函数视为黑盒，将现有Hash函数作为一个模块，预先封装，在需要时直接使用。</p>
<p><img src="/images/HMAC.JPG" alt="HMAC结构"></p>
<ul>
<li>H：嵌入的Hash函数</li>
<li>IV：Hash函数输入的初始化数组</li>
<li>M：HMAC的消息输入（包括由嵌入Hash函数定义的填充位）</li>
<li>$Y_i$：M的第i个分组</li>
<li>L：M中的分组个数</li>
<li>b：每一分组所含位数（bits）</li>
<li>n：嵌入的Hash函数所产生的Hash码长<h2 id="密钥运算"><a href="#密钥运算" class="headerlink" title="密钥运算"></a>密钥运算</h2>密钥运算包含两种操作（私钥操作、公钥操作），签名验签正是基于这两种操作：<br>$$<br>C=P^d mod n<br>$$</li>
</ul>
<p>$$<br>P=C^d mod n<br>$$</p>
<h3 id="签名验签"><a href="#签名验签" class="headerlink" title="签名验签"></a>签名验签</h3><p>使用签名的前提是使用公钥加密的密文只有私钥才能解开，使用私钥加密的密文只有公钥才能解开，确保了身份认证抗抵赖性。</p>
<p>过程：</p>
<ul>
<li>对原文摘要</li>
<li>A使用自己的私钥AS对摘要私钥加密运算，得到签名</li>
<li>B使用A的公钥AP对签名公钥解密运算，得到摘要值2，这一步证明签名来自A，若C伪造A的身份使用自己的私钥CP，则B的公钥解密失败。</li>
<li>B再使用和A相同的hash算法对原文摘要，得到摘要值3，这一步可用来验证原文是否遭到篡改，</li>
<li>B验证摘要值2和3是否相等</li>
</ul>
<p>至于填充模式，定义在PKCS#1：<code>00||BT||PS||00||D</code></p>
<ul>
<li>00保证大数是非负整数</li>
<li>BT分为00，01，02。00,01是私钥操作，02是公钥操作<ul>
<li>00：填充数据全为0X00，摘要必须以非0开头，如果摘要以0开头，将与填充数据无法区分</li>
<li>01：填充数据全为0XFF</li>
<li>02：填充数据必须为随机数</li>
</ul>
</li>
</ul>
<h3 id="非对称算法"><a href="#非对称算法" class="headerlink" title="非对称算法"></a>非对称算法</h3><p>非对称算法采用一对关联的公钥和私钥，公钥公开在互联网，解决了密钥配送的问题。</p>
<p>非对称算法用来在公开的网络上传输密钥依据以下<strong>两个特点</strong>：</p>
<ol>
<li>使用公钥加密的密文只有使用对应的私钥才能解开</li>
<li>使用私钥解密的密文只有使用对应的公钥才能解开</li>
</ol>
<p>分类：</p>
<ul>
<li>ECC算法（Elliptic Curve Cryptosystems, 椭圆曲线密码)</li>
<li>RSA算法</li>
</ul>
<p><strong>RSA</strong><br>使用RSA公钥运算，过程如下：</p>
<ul>
<li>对原文数据填充、封装-&gt;$P$</li>
<li>对P大数运算：$C=P^e mod n$</li>
</ul>
<p>使用RSA私钥运算，过程如下：</p>
<ul>
<li>对密文数据大数运算：$P=C^d mod n$</li>
<li>对P进行去填充</li>
</ul>
<p>以上可以看出，私钥解密和签名的运算过程一致！</p>
<p>用途：用于非对称传输信息，比如Bob有一个信息想传给Alice，需使用Alice的公钥加密信息，传给Alice，Alice得到加密信息后使用自己的私钥即可解开读取信息。他人即使截获加密信息也无法解开。</p>
<h3 id="国密算法"><a href="#国密算法" class="headerlink" title="国密算法"></a>国密算法</h3><p>SM2：椭圆曲线公钥密码算法<br>SM3：密码杂凑算法，用于数字签名和验证、消息认证码的生成、随机数的生成<br>SM4：分组加密算法，分组长度128bit，密钥长度128bi。32轮非平衡Feistel迭代结构，之后加上一个反序变换。</p>
<h1 id="规范"><a href="#规范" class="headerlink" title="规范"></a>规范</h1><h2 id="分组模式"><a href="#分组模式" class="headerlink" title="分组模式"></a>分组模式</h2><ul>
<li>ECB （Electronic Code book，电子密码本方式）明文分组与密文分组一一对应<ul>
<li>优点：最简单的一种模式，可并行运算，误差不会传递</li>
<li>缺点：若有相同明文分组，将被加密成相同密文分组，即明文的结构容易被泄露</li>
<li>CA产品的私钥保护使用ECB算法</li>
</ul>
</li>
<li>CBC （Cipher-block chaining，密码分组链接）明文分组首先与前一个密文分组XOR运算，然后再加密，这样做的目的就是改变明文分组的结构，由于第一个明文分组前没有密文分组，需增添IV初始化向量，与第一个明文分组XOR运算<ul>
<li>若密文分组损坏，但是长度没有改变，即仅改变几位的数据，解密后最多只影响两个明文分组（密文分组本身对应的明文分组，密文分组为后一个分组提供XOR伙伴的后一个明文分组）</li>
<li>若密文缺失bit，则缺失bit之后的密文全部无法解密</li>
</ul>
</li>
<li>CFB （Cipher Feedback ，密码反馈模式）明文分组与密钥XOR运算，CFB实现了一个被我称为伪伪随机数发生器的密码算法，它将前一个密文分组加密生成一个bit序列，称为密钥流（key stream），由于第一个明文分组前没有密文分组，需添加IV初始化向量，执行加密生成第一个密钥流。</li>
<li>OFB （Output Feedback  ，输出反馈模式）OFB与CFB相同的地方在于都是将明文分组与密钥XOR运算，区别就在于密钥的生成。OFB的密钥算法的输入来自于上一个密钥算法的输出。第一个密钥算法的输入使用一个IV向量</li>
</ul>
<p>OFB与CFB都采用将分组加密转换成流加密的方式</p>
<h2 id="填充模式"><a href="#填充模式" class="headerlink" title="填充模式"></a>填充模式</h2><ul>
<li>PKCS5Padding<br><img src="/images/PKCS5Padding.png" alt="PKCS5Padding"><br>如图，用自己的话来描述就是缺多少bit，就在每个bit里填多少。该方式是8分组结构，只适合DES/3DES。</li>
<li>PKCS7Padding<br>分组长度可以是小于255的任意长度</li>
<li>ZeroPadding<br>使用0X0补齐：<code>... | DD DD DD DD DD DD DD DD | DD DD DD DD 00 00 00 00 |</code></li>
<li>ANSI X.923<br>该模式在最后一个字节填缺少的bit数，其它补0X0（我觉得这个模式更符合一般人的想法）：<code>... | DD DD DD DD DD DD DD DD | DD DD DD DD 00 00 00 04 |</code></li>
<li>ISO 10126<br>该模式个人觉得稍好一些，最后一个填充位填写缺少的bit数，其它位填充随机数：<code>... | DD DD DD DD DD DD DD DD | DD DD DD DD 81 A6 23 04 |</code></li>
<li>ISO/IEC 7816-4<br>填充实例如下：<code>... | DD DD DD DD DD DD DD DD | DD DD DD DD 80 00 00 00 |</code>（未解）</li>
</ul>
<h2 id="PKCS-1"><a href="#PKCS-1" class="headerlink" title="PKCS#1"></a>PKCS#1</h2><p>定义RSA公私钥数据表达形式，及加密，解密，签名，验签，填充过程，定义了数字签名如何计算，包括签名数据和签名本身的格式。<br><strong>RSA公钥结构：</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">RSAPublicKey :: = SEQUENCE&#123;</span><br><span class="line">   modulus              INTEGER,   ------ n（RSA合数模）</span><br><span class="line">   publicExponent    INTEGER    ------ e （RSA公开幂，3～n-1范围内的正整数）</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>RSA公钥的ASN.1结构，可以表述为：名为RSAPublicKey的这个结构呢，就可以用来表述一个RSA公钥了。它有两个INTEGER型变量：modulus和publicExponent。<br><strong>RSA私钥结构：</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">RSAPrivateKey :: = SEQUENCE&#123;</span><br><span class="line">    version                 Version,（版本号，如果使用多素数，版本号为1）</span><br><span class="line">    modulus               INTEGER,   ------ n（RSA合数模）</span><br><span class="line">    publicExponent     INTEGER,   ------ e（RSA的公开幂）</span><br><span class="line">    privateExponent    INTEGER,   ------ d（RSA的私有幂）</span><br><span class="line">    prime1                 INTEGER,   ------ p（n的素数因子p）</span><br><span class="line">    prime2                 INTEGER,   ------ q（n的素数因子q）</span><br><span class="line">    exponent1            INTEGER,   ------ d mod (p -1)</span><br><span class="line">    exponent2            INTEGER,   ------ d mod (q -1)</span><br><span class="line">    coefficient            INTEGER,   ------- (inverse of q) mod p</span><br><span class="line">    otherPrimeInfos    OtherPrimeInfos   ------ OPTIONAL（当version为0时，不存在；当 version为1时，必须有）</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><strong>加密和签名方案的对象标识</strong><br>以下是对PKCS#1 OID的类型表示的定义<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">PKCS1Algorithms ALGORITHM-IDENTIFIER ::= &#123;</span><br><span class="line"> &#123; OID rsaEncryption PARAMETERS NULL &#125; |</span><br><span class="line"> &#123; OID md2WithRSAEncryption PARAMETERS NULL &#125; |</span><br><span class="line"> &#123; OID md5WithRSAEncryption PARAMETERS NULL &#125; |</span><br><span class="line"> &#123; OID sha1WithRSAEncryption PARAMETERS NULL &#125; |</span><br><span class="line"> &#123; OID sha256WithRSAEncryption PARAMETERS NULL &#125; |</span><br><span class="line"> &#123; OID sha384WithRSAEncryption PARAMETERS NULL &#125; |</span><br><span class="line"> &#123; OID sha512WithRSAEncryption PARAMETERS NULL &#125; |</span><br><span class="line">&#123; OID id-RSAES-OAEP PARAMETERS RSAES-OAEP-params &#125; |</span><br><span class="line"> PKCS1PSourceAlgorithms |</span><br><span class="line">&#123; OID id-RSASSA-PSS PARAMETERS RSASSA-PSS-params &#125; ,</span><br><span class="line"> ... -- Allows for future expansion --</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>规定了PKCS#1摘要和签名分别使用的算法，例如<code>sha1WithRSAEncryption</code>中<code>sha1</code>代表摘要使用的算法，<code>RSAEncryption</code>代表签名使用的算法<br><strong>RSAES-OAEP加密</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">RSAES-OAEP-params ::= SEQUENCE &#123;</span><br><span class="line"> hashAlgorithm [0] HashAlgorithm DEFAULT sha1,(标识了散列函数）</span><br><span class="line"> maskGenAlgorithm [1] MaskGenAlgorithm DEFAULT mgf1SHA1, （标识掩膜生成函数）</span><br><span class="line"> pSourceAlgorithm [2] PSourceAlgorithm DEFAULT pSpecifiedEmpty（标识标签L的源)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><code>hashAlgorithm</code>支持的散列函数：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">OAEP-PSSDigestAlgorithms ALGORITHM-IDENTIFIER ::= &#123;</span><br><span class="line"> &#123; OID id-sha1 PARAMETERS NULL &#125;|</span><br><span class="line">&#123; OID id-sha256 PARAMETERS NULL &#125;|</span><br><span class="line">&#123; OID id-sha384 PARAMETERS NULL &#125;|</span><br><span class="line">&#123; OID id-sha512 PARAMETERS NULL &#125;,</span><br><span class="line"> ... -- Allows for future expansion --</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="PKCS-5"><a href="#PKCS-5" class="headerlink" title="PKCS#5"></a>PKCS#5</h2><p>基于口令的加密规范Password-Based Cryptography Specification</p>
<p>目的：保护私钥文件的安全性</p>
<p>通过将原始口令+salt派生出新口令进行加密</p>
<p>PKSC5Padding（用于制定算法DES）对称加密填充方式，填充块固定为8个字节，填充值为待填充的长度，与PKCS7Padding类似。</p>
<h2 id="PKCS-7"><a href="#PKCS-7" class="headerlink" title="PKCS#7"></a>PKCS#7</h2><p>加密消息的语法标准Cryptographic Message Syntax Version 1.5<br>结构：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">pkcs7_st</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  <span class="comment">/* 其他项 */</span></span><br><span class="line"></span><br><span class="line">  ASN1_OBJECT *type;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">union</span></span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">char</span> *ptr;</span><br><span class="line">   <span class="comment">/* NID_pkcs7_data */</span></span><br><span class="line">   ASN1_OCTET_STRING *data;</span><br><span class="line"></span><br><span class="line">   <span class="comment">/* NID_pkcs7_signed */</span></span><br><span class="line">   PKCS7_SIGNED *sign;</span><br><span class="line"></span><br><span class="line">   <span class="comment">/* NID_pkcs7_enveloped */</span></span><br><span class="line">   PKCS7_ENVELOPE *enveloped;</span><br><span class="line"></span><br><span class="line">   <span class="comment">/* NID_pkcs7_signedAndEnveloped */</span></span><br><span class="line">   PKCS7_SIGN_ENVELOPE *signed_and_enveloped;</span><br><span class="line"></span><br><span class="line">   <span class="comment">/* NID_pkcs7_digest */</span></span><br><span class="line">   PKCS7_DIGEST *digest;</span><br><span class="line"></span><br><span class="line">   <span class="comment">/* NID_pkcs7_encrypted */</span></span><br><span class="line">   PKCS7_ENCRYPT *encrypted;</span><br><span class="line"></span><br><span class="line">   <span class="comment">/* Anything else */</span></span><br><span class="line">   ASN1_TYPE *other;</span><br><span class="line"> &#125; d;</span><br><span class="line">&#125; PKCS7;</span><br></pre></td></tr></table></figure></p>
<p>pkcs7 各种类型数据结构的 DER 编解码通过宏在 crypto/pkcs7/pk7_asn1.c 中实现</p>
<ul>
<li>可以包含6种类型的数据:<ul>
<li>id-data: 任意数据，由应用解析，可以是明文数据。</li>
<li>id-signedData: 签名数据</li>
<li>id-envelopedData: 加密数据</li>
<li>id-signedAndEnvelopedData: 签名又加密数据，数字信封</li>
<li>id-digestedData: 摘要数据，原文及摘要结果</li>
<li>id-encryptedData: 只有加密数据，密钥在带外传送、管理</li>
</ul>
</li>
</ul>
<p>数字信封流程：（A：发送方；B：接收方；SK：私钥；PK：公钥）</p>
<ul>
<li>A对<strong>明文</strong>进行hash运算，得到<strong>摘要</strong></li>
<li>A用自己的私钥<strong>A:SK</strong>对摘要进行RSA私钥加密运算，得到A的<strong>数字签名</strong></li>
<li>A随即产生一个用于特定加密算法的<strong>加密密钥</strong>（DES密钥），并使用该密钥对<strong>明文</strong>进行对称加密，形成<strong>密文</strong></li>
<li><p>A使用B的公钥<strong>B:PK</strong>对随机产生的加密密钥进行RSA公钥加密运算，并将结果与密文一同传送给B</p>
</li>
<li><p>B用自己的私钥<strong>B:SK</strong>对对称加密的结果进行RSA私钥解密运算，得到A随机产生的对称<strong>加密密钥</strong></p>
</li>
<li>B用<strong>加密密钥</strong>对密文解密，得到<strong>明文</strong></li>
<li>B用A的公钥<strong>A:PK</strong>对A的<strong>数字签名</strong>进行RSA公钥解密运算，得到A的<strong>信息摘要</strong></li>
<li>B用相同的hash算法对明文进行hash运算，得到新的信息摘要，并与收到的信息摘要比较，若一致，则说明明文未被修改，来自A。</li>
</ul>
<p>常用的用途有:</p>
<ul>
<li>证书链</li>
<li>数字信封</li>
<li>带原文的签名数据</li>
</ul>
<p><a href="http://hbaojun.github.io/2014/02/18/PKCS7%E7%BB%93%E6%9E%84%E5%88%86%E6%9E%90%E4%B9%8B%E7%AD%BE%E5%90%8D/" target="_blank" rel="noopener">PKCS#7结构分析之签名</a></p>
<p><a href="http://hbaojun.github.io/2014/02/19/PKCS7%E7%BB%93%E6%9E%84%E5%88%86%E6%9E%90%E4%B9%8B%E6%95%B0%E5%AD%97%E4%BF%A1%E5%B0%81/" target="_blank" rel="noopener">PKCS#7结构分析之数字信封</a></p>
<h2 id="附：数字信封"><a href="#附：数字信封" class="headerlink" title="附：数字信封"></a>附：数字信封</h2><p><img src="/images/envelop.png" alt="加密图解"></p>
<p>构造数字信封要能够达到以下功能：</p>
<ul>
<li>保密（对称加密，RSA公钥加密）</li>
<li>验证完整性（MAC值）</li>
<li>验证身份（签名）</li>
</ul>
<p>因此该结构应该包含：</p>
<ul>
<li>明文加密后的密文cryptodata</li>
<li>Hash函数生成的MAC值</li>
<li>RSA私钥加密的签名值signdata</li>
<li>（也应该包含证书，由CA担保身份）</li>
</ul>
<h2 id="PKCS-8"><a href="#PKCS-8" class="headerlink" title="PKCS#8"></a>PKCS#8</h2><p>私钥封装格式Private_Key Information Syntax Specification Version 1.2</p>
<p>定义了私钥信息语法和加密私钥语法。<br>私钥类型任意，对称算法可设置</p>
<h2 id="PKCS-10"><a href="#PKCS-10" class="headerlink" title="PKCS#10"></a>PKCS#10</h2><p>证书请求格式（主题，公钥，私钥签名）</p>
<p>RA注册流程：注册信息-&gt;审核通过-&gt;生成密钥-&gt;生成PKCS10请求-&gt;将信息和P10请求的公钥合并成CMP请求-&gt;发送到CA</p>
<h2 id="PKCS-11"><a href="#PKCS-11" class="headerlink" title="PKCS#11"></a>PKCS#11</h2><p>介质接口格式：</p>
<ul>
<li>硬件驱动</li>
<li>定义文件操作</li>
<li>权限管理</li>
</ul>
<p>对应于Windows的CSP，国密接口的SKF</p>
<h2 id="PKCS-12"><a href="#PKCS-12" class="headerlink" title="PKCS#12"></a>PKCS#12</h2><p>带私钥的个人证书格式，包含私钥、证书、证书链、CRL…</p>
<h2 id="X-509"><a href="#X-509" class="headerlink" title="X.509"></a>X.509</h2><p><a href="https://tools.ietf.org/html/rfc5280" target="_blank" rel="noopener">X.509证书与509黑名单规范</a></p>
<p>X.509数字证书主体如下：</p>
<ul>
<li>签名前的证书申请（签名对象的信息）</li>
<li>数字签名的算法（CA对证书签名使用的算法）</li>
<li>数字签名（用于验证证书的有效性，使用者使用CA的公钥使用同种算法对证书签名，查看和该数字签名是否相同）</li>
</ul>
<p>一个真实的X509数字证书包含：</p>
<ul>
<li>证书版本（V3）</li>
<li>证书序列号</li>
<li>签名算法（sha1RSA）</li>
<li>签名哈希算法（sha1）</li>
<li>签名</li>
<li>颁发者信息<ul>
<li>CN</li>
<li>OU</li>
<li>O组织</li>
<li>L地点</li>
<li>S州</li>
<li>C </li>
</ul>
</li>
<li>使用者信息</li>
<li>有效期</li>
<li>公钥</li>
<li>密钥用法<ul>
<li>Key Encipherment, Data Encipherment </li>
<li>Digital Signature, Non-Repudiation</li>
</ul>
</li>
<li>CRL分发点</li>
<li>指纹算法</li>
<li>指纹</li>
</ul>
<p><strong>结构</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">x509_st</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    X509_CINF *cert_info;</span><br><span class="line">    X509_ALGOR *sig_alg;</span><br><span class="line">    ASN1_BIT_STRING *signature;</span><br><span class="line">    <span class="keyword">int</span> valid;</span><br><span class="line">    <span class="keyword">int</span> references; </span><br><span class="line">    <span class="keyword">char</span> *name;</span><br><span class="line">    CRYPTO_EX_DATA ex_data;</span><br><span class="line">    <span class="keyword">long</span> ex_pathlen;</span><br><span class="line">    <span class="keyword">long</span> ex_pcpathlen;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> ex_flags;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> ex_kusage;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> ex_xkusage;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> ex_nscert;</span><br><span class="line">    ASN1_OCTET_STRING *skid;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">AUTHORITY_KEYID_st</span> *<span class="title">akid</span>;</span></span><br><span class="line">    X509_POLICY_CACHE *policy_cache;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> OPENSSL_NO_SHA</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">char</span> sha1_hash[SHA_DIGEST_LENGTH];</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">    X509_CERT_AUX *aux; </span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>以上结构表示一个完整的数字证书，主要项如下：</p>
<ul>
<li>cert_info:证书主体信息；</li>
<li>sig_alg:签名算法；</li>
<li>signature:签名值，存放CA对该证书采用sig_alg算法签名的结果（验证证书持有者身份时，使用该CA公钥对该证书采用sig_alg签名算法签名得到signature1，将两个签名值比较，若相等，则表明是通过CA确认的证书持有者）；</li>
<li>valid：是否是合法证书，1 为合法，0 为未知；</li>
<li>references：引用次数，被引用一次则加一；</li>
<li>name：证书持有者信息该内容在调用 d2i_X509的过程中，通过回调函数 x509_cb(crypto/asn1/x_x509.c)调用 X509_NAME_oneline 来设置；</li>
</ul>
<p><strong>编程接口</strong><br>DER 编解码接口由宏在 crypto/asn1/x_x509.c 中实现，包括各自的new、free、i2d 和 d2i 函数：</p>
<ul>
<li>d2i_X509：解码 DER 编码的数字证书</li>
<li>PEM_read_bio_X509：从PEM格式的数字证书中得到X509数据结构</li>
</ul>
<h2 id="ASN-1"><a href="#ASN-1" class="headerlink" title="ASN.1"></a>ASN.1</h2><p>Abstract Syntax Notation One，抽象语法标识，是与平台、语言无关的数据结构定义语法</p>
<p><strong>编码格式</strong><br>BER、CER、DER、XER，可以编码成XML格式，不仅仅是常用的二进制流。<br>二进制流的TLV方式表达数据结构，如下：</p>
<table>
<thead>
<tr>
<th style="text-align:center"></th>
<th style="text-align:center"></th>
<th style="text-align:center"></th>
<th style="text-align:center"></th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">Identifier octets Type</td>
<td style="text-align:center">Length octets Length</td>
<td style="text-align:center">Contents octets Value</td>
<td style="text-align:center">End-of-contents octets</td>
</tr>
</tbody>
</table>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">Personnel</span><br><span class="line">Record     Length   Contents</span><br><span class="line">60         8185</span><br><span class="line">                    Name     Length  Contents</span><br><span class="line">                    61       10</span><br><span class="line">                                     VisibleString  Length  Contents</span><br><span class="line">                                     1A             04      &quot;John&quot;</span><br><span class="line">                                     VisibleString  Length  Contents</span><br><span class="line">                                     1A             01      &quot;P&quot;</span><br><span class="line">                                     VisibleString  Length  Contents</span><br><span class="line">                                     1A             05      &quot;Smith&quot;</span><br><span class="line"></span><br><span class="line">                     DateofBirth     Length  Contents</span><br><span class="line">                     A0              0A</span><br><span class="line">                                             Date    Length  Contents</span><br><span class="line">                                             43      08      &quot;19590717&quot;</span><br></pre></td></tr></table></figure>
<ul>
<li>BER: Basic Encoding Rules<ul>
<li>基本编码格式。</li>
<li>对相同的数据，可以有多种编码方式，比如长字节型、短字节型、不定长型等。</li>
</ul>
</li>
<li>DER: Distinguished Encoding Rules<ul>
<li>是BER的一个子集，为更严格的一个变种版本。</li>
<li>和BER相比，DER的编码格式只有固定一种。比如BER的Boolean变量编码值是可以1~255的任意值，而DER只能是1。</li>
<li><strong>DER使用在有数据签名的场合</strong>，以保证数据原文编码后可以保持一致。</li>
<li>X.509证书都是DER编码。</li>
</ul>
</li>
<li>CER: Canonical Encoding Rules<ul>
<li>CER和DER一样，都是BER的限定编码规则的子集。</li>
<li>CER和DER不同在于它是不定长编码，可以用于大数据块的封装。</li>
<li>PKCS#7数字信封可以用DER编码，也可以用CER编码。</li>
</ul>
</li>
</ul>
<ul>
<li>Privacy Enhanced Mail: 安全增强邮件，通过加密算法、证书加密邮件。<ul>
<li>更常用的概念是一种文件格式，该文件格式使用一个头、尾标识文件的内容，以方便解析。如下:</li>
<li>被加密的私钥:</li>
</ul>
</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">-----BEGIN ENCRYPTED PRIVATE KEY-----</span><br><span class="line">...</span><br><span class="line">-----END ENCRYPTED PRIVATE KEY-----</span><br></pre></td></tr></table></figure>
<ul>
<li>PEM格式的证书:</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">-----BEGIN CERTIFICATE-----</span><br><span class="line">...</span><br><span class="line">-----END CERTIFICATE-----</span><br></pre></td></tr></table></figure>
<ul>
<li>PEM格式的PKCS#10证书请求:</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">-----BEGIN CERTIFICATE REQUEST-----</span><br><span class="line">...</span><br><span class="line">-----END CERTIFICATE REQUEST-----</span><br></pre></td></tr></table></figure>
<ul>
<li><p>CER、DER、CRT、PEM的关系</p>
<ul>
<li>所有X.509都是DER编码，DER是指ASN.1的编码规则，.der证书文件一般是二进制文件。</li>
<li>CER可用于PKCS#7证书(p7b)的编码，但一般是指证书的文件后缀，.cer证书可以是纯BASE64文件或二进制文件。</li>
<li>PEM通常也是指文件的后缀，为内容使用BASE64编码且带头带尾的特定格式，二进制的文件不应该命名为pem。</li>
<li>CRT是微软的证书后缀名，和.CER是一回事。</li>
<li>微软的CryptAPI很强大，证书的各种格式都可以识别，比如纯BASE64编码的、标准PEM格式的、非标识PEM格式的(不是64字节换行、没有头尾等)、二进制格式的。</li>
<li>但openssl、JCE则不行，必须是标准的PEM格式和DER格式。</li>
<li>references:<ul>
<li><a href="http://www.cryptologie.net/article/260/asn1-vs-der-vs-pem-vs-x509-vs-pkcs7-vs/" target="_blank" rel="noopener">http://www.cryptologie.net/article/260/asn1-vs-der-vs-pem-vs-x509-vs-pkcs7-vs/</a></li>
<li><a href="http://myonlineusb.wordpress.com/2011/06/19/what-are-the-differences-between-pem-der-p7bpkcs7-pfxpkcs12-certificates/" target="_blank" rel="noopener">http://myonlineusb.wordpress.com/2011/06/19/what-are-the-differences-between-pem-der-p7bpkcs7-pfxpkcs12-certificates/</a></li>
</ul>
</li>
</ul>
</li>
<li><p>PFX</p>
<ul>
<li>Personal Information Exchange</li>
<li>PKCS#12是PFX的后续版本，一般情况二者为等同概念。</li>
<li>PFX或PKCS#12，是包括私钥的个人证书，通过口令保护私钥。</li>
<li>后缀名为.pfx或.p12</li>
<li>使用openssl、keytool、Portecle(KeyStore工具)都可以很方便生成PFX证书。</li>
<li>references:<ul>
<li><a href="http://en.wikipedia.org/wiki/PKCS_12" target="_blank" rel="noopener">http://en.wikipedia.org/wiki/PKCS_12</a></li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="CRL"><a href="#CRL" class="headerlink" title="CRL"></a>CRL</h2><p>证书撤销列表(Certificate Revocation List，简称 CRL)，是一种包含撤销的证书列表的签名数据结构。基本的 CRL 信息有：被撤销证书序列号、撤销时间、撤销原因、签名者以及 CRL 签名等信息。</p>
<p>被撤销证书的信息：X509_REVOKED</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">X509_revoked_st</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    ASN1_INTEGER *serialNumber;</span><br><span class="line">    ASN1_TIME *revocationDate;</span><br><span class="line">    STACK_OF(X509_EXTENSION) *extensions;</span><br><span class="line">    <span class="keyword">int</span> sequence;</span><br><span class="line">&#125; X509_REVOKED;</span><br></pre></td></tr></table></figure>
<ul>
<li>serialNumber：被撤销证书的序列号；</li>
<li>revocationDate：撤销时间；</li>
<li>extensions：扩展项，可选；</li>
<li>sequence：顺序号，用于排序，表示当前被撤销证书信息在 crl 中的顺序。</li>
</ul>
<p>crl信息主体：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">X509_crl_info_st</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    ASN1_INTEGER *version;</span><br><span class="line">    X509_ALGOR *sig_alg;</span><br><span class="line">    X509_NAME *issuer;</span><br><span class="line">    ASN1_TIME *lastUpdate;</span><br><span class="line">    ASN1_TIME *nextUpdate;</span><br><span class="line">    STACK_OF(X509_REVOKED) *revoked; </span><br><span class="line">    STACK_OF(X509_EXTENSION) *extensions;</span><br><span class="line">    ASN1_ENCODING enc;</span><br><span class="line">&#125; X509_CRL_INFO;</span><br></pre></td></tr></table></figure>
<ul>
<li>version：crl 版本；</li>
<li>sig_alg：crl 签名算法；</li>
<li>issuer：签发者信息；</li>
<li>lastUpdate：上次更新时间；</li>
<li>nextUpdate：下次更新时间；</li>
<li>revoked：被撤销证书信息；</li>
<li>extensions：扩展项，可选。</li>
</ul>
<p>完整crl数据结构：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">X509_crl_st</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    X509_CRL_INFO *crl;</span><br><span class="line">    X509_ALGOR *sig_alg;</span><br><span class="line">    ASN1_BIT_STRING *signature;</span><br><span class="line">    <span class="keyword">int</span> references;</span><br><span class="line">&#125; ;</span><br></pre></td></tr></table></figure>
<ul>
<li>crl：crl 信息主体；</li>
<li>sig_alg：签名算法，与 X509_CRL_INFO 中的一致；</li>
<li>signature：签名值；</li>
<li>references：引用</li>
</ul>
<h2 id="附3-LDAP"><a href="#附3-LDAP" class="headerlink" title="附3 LDAP"></a>附3 LDAP</h2><p>轻量目录访问协议(Lightweight Directory Access Protocol)，运行于TCP/IP之上。</p>
<p>目录的信息按照树型结构组织，数据结构：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">条目entry-&gt;区别名DN-&gt;属性Attribute-&gt;类型Type</span><br><span class="line">                                |</span><br><span class="line">                                -&gt;值Values</span><br></pre></td></tr></table></figure></p>
<h2 id="附4-OCSP"><a href="#附4-OCSP" class="headerlink" title="附4 OCSP"></a>附4 OCSP</h2><p>在线证书状态协议（Online Certificate Status Protocol)</p>
<p>数据格式：</p>
<ul>
<li>协议版本</li>
<li>服务请求</li>
<li>目标证书标识</li>
<li>可能被OCSP响应器处理的可选扩展</li>
</ul>
<p>OCSP响应端检测：</p>
<ul>
<li>信息正确格式化</li>
<li>响应器被配置提供请求服务而且</li>
<li>请求包含了响应器需要的信息，返回一个确定的回复，OCSP响应端回复的加密消息中包含证书的状态可以是’good’,’revoked’或者’unknown’</li>
<li>如果任何一个先决条件没有满足，那么OCSP响应器将产生一个错误信息，错误码可能包含以下内容：<ul>
<li>未正确格式化的请求（malformedRequest）</li>
<li>内部错误（internalError）</li>
<li>请稍后再试(trylater)</li>
<li>需要签名(sigRequired)</li>
<li>未授权(unauthorized)</li>
</ul>
</li>
</ul>
<h2 id="数字证书"><a href="#数字证书" class="headerlink" title="数字证书"></a>数字证书</h2><p><strong>发证流程：</strong></p>
<ul>
<li>申请者将合法的身份信息（参考X509章节）以PKCS#10格式通过SCEP（简单证书颁发协议，工作在HTTP之上）发送给CA，</li>
<li>CA验证申请者的合法性，满足条件就会产生一个合法的证书，内容包括身份信息、公钥、CA信息、CA签名、有效时间、序列号、CRL表的下载地址或查询地址</li>
<li>CA使用申请者公钥将X.509v3加密得到密文格式证书，使用SCEP协议颁发给申请者</li>
<li>申请者使用自己的私钥解密得到X.509v3证书并保存</li>
</ul>
<p><strong>双证书：</strong><br>双证书即双密钥（签名密钥对，加密密钥对）</p>
<ul>
<li>签名密钥对用于数据完整性检测，保证放伪造与防抵赖，若遗失，不影响以前数据的验证。因此不需要第三方管理。</li>
<li>加密密钥对用于数据的加密保护，若遗失，将导致之前加密的数据无法解密。因此加密密钥对应有可信第三方（CA）产生备份。</li>
</ul>
<p>（附：我曾今将整理的文件使用一款加密软件加密，选择加密密码的时候由于自己记不住长密码，又不想将长密码以任何形式记录下来，于是决定使用自认为固定的文件作为密钥，然后当再次使用文件解密的时候，被告知不是该文件。才想起，这个当时在我看来是固定的文件，由于版本需要被我修改了！整理的三个月的文件就这样脱胎换骨成了0110…）<br><strong>验证过程</strong></p>
<ol>
<li>拆封证书<ul>
<li>目的：获取证书中的公钥</li>
</ul>
</li>
<li>验证证书链<ul>
<li>目的：验证签发用户实体证书的CA是否是权威可信的CA</li>
<li>操作：使用每级CA的公钥验证每级数字签名</li>
</ul>
</li>
<li>验证序列号<ul>
<li>目的：检查实体证书中的签名实体序列号是否与签发者证书的序列号相一致</li>
<li>操作：用户实体证书中的Authority Key Identifier扩展项Cert Serial Number,即签发证书的序列号与CA证书中的Certificate Serial Number 证书序列号是否一致</li>
</ul>
</li>
<li>证书废止列表查询（黑名单查询，CRL）<ul>
<li>目的：检查用户证书是否作废</li>
</ul>
</li>
</ol>
<h1 id="OpenSSL"><a href="#OpenSSL" class="headerlink" title="OpenSSL"></a>OpenSSL</h1><h2 id="命令行"><a href="#命令行" class="headerlink" title="命令行"></a>命令行</h2><p><strong>构建数字证书</strong><br>主要操作包括产生私钥（key），构造证书请求（req），签发用户证书，自签发根证书。</p>
<ul>
<li>1.产生私钥（带密码保护）：<code>openssl genrsa -out mysite.key -des3 -passout pass:123456 1024</code></li>
<li>2.构造证书请求<ul>
<li>交互式输入：<code>openssl req -key mysite.key -passin pass:123456 -new -out mysite.req</code></li>
<li>非交互式输入，先编辑配置文件mysite.conf，然后生成请求：<code>openssl req -key mysite.key -passin pass:123456 -new -config mysite.conf -out mysite.req</code></li>
</ul>
</li>
<li>3.签发用户证书：<code>openssl x509 -req -in mysite.req -CA testca.pem -CAkey testca.key -out mysite.pem -passin pass:abcdef -CAcreateserial</code>-days指定证书有效期</li>
<li>当然，签发用户证书的前提是已经自签发根证书，先执行1,2步生成根证书申请，然后自签发：<code>openssl x509 -req -in testCA.req -signkey testca.key -out testca.pem -passin pass:abcdef</code></li>
</ul>
<h2 id="编程"><a href="#编程" class="headerlink" title="编程"></a>编程</h2><p>对称算法和摘要算法全局初始化：<code>OpenSSL_add_all_algorithms();</code></p>
<p>释放句柄：<code>EVP_MD_CTX_cleanup(&amp;ctx);</code></p>
<h3 id="加解密"><a href="#加解密" class="headerlink" title="加解密"></a>加解密</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">int EVP_CipherInit(EVP_CIPHER_CTX *ctx, const EVP_CIPHER *type, unsigned char *key, unsigned char *iv, int enc)</span><br><span class="line">int EVP_CipherUpdate(EVP_CIPHER_CTX *ctx, unsigned char *out, int *outl, unsigned char *in, int inl);</span><br><span class="line">int EVP_CipherFinal(EVP_CIPHER_CTX *ctx, unsigned char *outm, int *outl);</span><br></pre></td></tr></table></figure>
<h3 id="摘要"><a href="#摘要" class="headerlink" title="摘要"></a>摘要</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">int EVP_DigestInit(EVP_MD_CTX *ctx, const EVP_MD *type);</span><br><span class="line">int EVP_DigestUpdate(EVP_MD_CTX *ctx, const void *d, size_t cnt);</span><br><span class="line">int EVP_DigestFinal(EVP_MD_CTX *ctx, unsigned char *md, unsigned int *s);</span><br></pre></td></tr></table></figure>
<h3 id="签名验签-RSA-ECDSA"><a href="#签名验签-RSA-ECDSA" class="headerlink" title="签名验签(RSA/ECDSA)"></a>签名验签(RSA/ECDSA)</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">EVP_SignInit ( &amp;md_sign_ctx, md )</span><br><span class="line">EVP_SignUpdate(&amp;md_sign_ctx, data, data_cb)</span><br><span class="line">EVP_SignFinal (&amp;md_sign_ctx, sign, psign_cb, pPriKey )</span><br><span class="line"></span><br><span class="line">EVP_VerifyInit( &amp;md_verify_ctx, md )</span><br><span class="line">EVP_VerifyUpdate(&amp;md_verify_ctx, data, data_cb)</span><br><span class="line">EVP_VerifyFinal(&amp;md_verify_ctx, sign, sign_cb, pPubKey)</span><br></pre></td></tr></table></figure>
<h3 id="公钥加密与私钥解密（RSA算法）"><a href="#公钥加密与私钥解密（RSA算法）" class="headerlink" title="公钥加密与私钥解密（RSA算法）"></a>公钥加密与私钥解密（RSA算法）</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">int EVP_PKEY_encrypt	(	EVP_PKEY_CTX * 	ctx, unsigned char * 	out, size_t * 	outlen, const unsigned char * 	in, size_t 	inlen )</span><br></pre></td></tr></table></figure>
<h3 id="PKCS7签名验签（RSA-ECDSA）"><a href="#PKCS7签名验签（RSA-ECDSA）" class="headerlink" title="PKCS7签名验签（RSA/ECDSA）"></a>PKCS7签名验签（RSA/ECDSA）</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">p7 = PKCS7_sign(x, pPriKey, NULL, in, PKCS7_BINARY)</span><br><span class="line">PKCS7_verify(p7, NULL, NULL, in, NULL, PKCS7_BINARY|PKCS7_NOVERIFY)</span><br></pre></td></tr></table></figure>
<h3 id="PKCS7数字信封加密解密（RSA）"><a href="#PKCS7数字信封加密解密（RSA）" class="headerlink" title="PKCS7数字信封加密解密（RSA）"></a>PKCS7数字信封加密解密（RSA）</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">p7 = PKCS7_encrypt(certs, in, EVP_des_cbc(), PKCS7_BINARY)</span><br><span class="line">PKCS7_decrypt(p7, pPriKey, x, out, PKCS7_BINARY)</span><br></pre></td></tr></table></figure>
<h3 id="解密公司的加密邮件（SMIME）"><a href="#解密公司的加密邮件（SMIME）" class="headerlink" title="解密公司的加密邮件（SMIME）"></a>解密公司的加密邮件（SMIME）</h3><p>公司加密邮件为标准SMIME格式，导出后得到.eml文件<br>使用<code>PKCS7 *SMIME_read_PKCS7(BIO *bio, BIO **bcont)</code>将bio读取到的SMIME格式保存在PKCS7格式内，然后通过PKCS7_dncrypt接口解密</p>
<h3 id="错误处理"><a href="#错误处理" class="headerlink" title="错误处理"></a>错误处理</h3><p>错误处理应该尽可能多的包含各种信息，包括：</p>
<ul>
<li>错误码；</li>
<li>出错文件以及行号；</li>
<li>错误原因；</li>
<li>出错函数；</li>
<li>出错库；</li>
<li>出错模块与类别信息；</li>
<li>错误堆栈信息等。</li>
</ul>
<p>ERR_get_error获取第一个错误号</p>
<p>ERR_error_string根据错误码获取具体的错误信息，包括出错的库、出错的函数以及出错原因</p>
<p>ERR_print_errors_fp将错误打印到FILE中</p>

          
        
      
    </div>

    

    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://renzheng0403.github.io/2017/07/02/《白夜行》读后感——夜行者/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="renzheng">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="renz">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2017/07/02/《白夜行》读后感——夜行者/" itemprop="url">
                  夜行者
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">

            
            
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              

              
                
              

              <time title="创建时间：2017-07-02 05:04:00" itemprop="dateCreated datePublished" datetime="2017-07-02T05:04:00+08:00">2017-07-02</time>
            

            
              

              
                
                <span class="post-meta-divider">|</span>
                

                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                
                  <span class="post-meta-item-text">更新于</span>
                
                <time title="修改时间：2018-05-19 09:59:30" itemprop="dateModified" datetime="2018-05-19T09:59:30+08:00">2018-05-19</time>
              
            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/后感/" itemprop="url" rel="index"><span itemprop="name">后感</span></a></span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>大概是用了连着的12多个小时读完，中间只睡了4个小时。这是一本读了就让我放不下的书。这本书在我这放了有一年多了，同学和我换书看，但是一直忙于各种事，文学类的书少见的没有顾及，因此一直保持封皮未拆封的状态。这次决定看也是另一个老朋友突然提到，才想起自己手头刚好有一本。</p>
<p>我们身边总会存在这样一些人，他们身上有一种高尚的气息，未加掩饰的纯洁。提起这个人，别人会觉得，哦，他啊，不是那种做这种龌龊事的人，而提起另外一个人，仿佛他脸上写着阴谋。对第一种人心之所向无可厚非，对第二种人呲之以鼻也是人之常情，我并不想为来自社会底层的陋习做任何正名的事，我自己也厌恶那些，但读完《白夜行》，很难不去想为什么有些人总是走在灰色边缘，原因很简单啊——我的世界里根本没有太阳。</p>
<hr>
<p>什么样的人生叫没有太阳？川岛江利子是女主唐泽雪穗的中学和大学好友，尽管她在大学发生了那种事，但是究其本身的生长环境来说，她不是夜行者，所以可以看到她身上有人最崇高的品质。我没有细查作者在前期是怎样描绘江利子，总之是个其貌不扬呆在唐泽雪穗身边乖乖女。开篇介绍她的良好习惯——就寝前写日记，上学前为院子里的树浇水，星期日早上打扫房间。关于日记是这样描写的：</p>
<blockquote>
<p>不需要写什么戏剧性的大事，平铺直叙也无妨，即便是一句“今天一如往常”亦无不可。</p>
</blockquote>
<p>她憧憬能够与雪穗交朋友，在和她在一起之后更是觉得自己也对许多事物有了新的认识。文章也说了由于男生的目光都集中在雪穗身上，她难免也会有些嫉妒，但是这种嫉妒也仅限于一种未控制生物本能，在之后甚至连这种生物本能都完全消失。简而言之，江利子身上有一种称之为贵族气息的优雅，不争不抢，仿佛岁月静好。她的这个优点被来自上层社会的具有敏锐观察力的筱冢一成一眼识别。</p>
<p>灰姑娘的故事不是吗？假如不是发生后面的事，她会是第二个灰姑娘。习惯、容貌、礼仪等都是可以学习的技巧，但是那份宠辱不惊的心态是雪穗无论如何都学不来的。毕竟人，生来不平等。</p>
<hr>
<p>与之相对，唐泽雪穗的人生则是没有太阳的人生。人类从幼年到成年用时惊人，在这段漫长的岁月里，我们几乎没有任何自卫的能力，完全庇护在看护人的保护下，然而雪穗的看护人——其母西本文代，却因为种种原因，将这个残酷的世界暴露在一个小女孩的面前。年幼的西本雪穗面对的不仅仅是一个或者一次，她面对的是桐原洋介、寺崎忠夫等在未解决好个人人性而暴露出来的原罪——欲。</p>
<p>这样的一个人，在以后的岁月里，你指望她也能闲看花开花落，云起云涌吗？她只会尽全力将自己武装起来，任何人对她来说都将是工具，因为她无法信任任何人。毕竟在她年幼的时候，自己的母亲都不值得信任。</p>
<p>在她被唐泽礼子收养之后，她是否曾放下自己的心房呢？你尽可以猜测，由于唐泽礼子家娴静的环境，不愁吃穿不惧生活，她也会获得真正的快乐吧，从而放下罪恶。加入你真有这种想法，哪怕一刻钟，就表明你更偏向于川岛江利子式而不是唐泽雪穗式的思考方式。进入唐泽礼子家是雪穗内心权衡的对自己最有利的选择。年幼的她在生母还在世的时候，有两个地方会带给她内心的一些依靠，一个是图书馆，另一个就是唐泽礼子家，这两个地方带给她的均是逃，逃避了现世的残酷。在图书馆里，阅读带人沉浸在书所描绘的世界，而与远房亲戚唐泽礼子的交流则让她体会到了一个完全不同于自己生母所提供的生活环境，那里谈吐优雅洁净，心之所向大概就是这种感觉。</p>
<p>在发现自己的母亲自杀后，她冷静的分析现状，并布置了意外死亡的假象，又借由无法找到钥匙的理由，耽误了救治的最佳时间。结果最终如她所愿，如愿以偿的被收养。从此以后，她的行事准则只看是否对自己有利，而不会再去关心爱护身边的人。加入你能感受到她对你的关心，对她来说却仅仅是方程式一般的必做事项，无所谓感情。</p>
<blockquote>
<p>我的天空里没有太阳，总是黑夜，但并不暗，因为有东西代替了太阳。虽然没有太阳那么明亮，但对我来说已经足够。凭借着这份光，我便能把黑夜当成白天。我从来就没有太阳，所以不怕失去。</p>
</blockquote>
<p>这段话算是雪穗的自白了吧。代替了太阳的应该就是桐原亮司，桐原亮司是她的图书馆小伙伴，最重要的是，在她最绝望的时候，他为她黑暗的人生点亮了一盏灯，将她从越陷越深的泥淖里解救了出来。“并不暗，有东西代替了太阳。”光是说出这句话，内心的幸福感恐怕都要爆棚。</p>
<p>我们可以说川岛江利子天生幸运，又是不幸的；而唐泽雪穗是天生不幸，又是幸运的。在于人生路上的光，雪穗遇到了伴随她行走的光，因此即使是在黑夜，她都有走下去的勇气。雪穗的另一句话：</p>
<blockquote>
<p>有些人一辈子都活在太阳的照耀下，也有些人不得不一直活在漆黑的深夜里。人害怕的是本来一直存在的太阳落下不再升起，也就是非常害怕原来照在身上的光芒突然消失。</p>
</blockquote>
<p>全文的最后，桐原亮司死之后是这样描述雪穗的：</p>
<blockquote>
<p>只见雪穗正沿扶梯上楼，她的背影犹如白色的影子。<br>她一次都没有回头。</p>
</blockquote>
<p>这段描述突然让我想起了小时候看的一个镜头：<br><img src="http://upload-images.jianshu.io/upload_images/5278708-b0cb5df6a8b6cd9b.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="天下无贼.png"></p>
<p>雪穗已经死了，因为照在她身上的光已经消失。</p>

          
        
      
    </div>

    

    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
  </section>

  


          </div>
          

        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      

      <section class="site-overview-wrap sidebar-panel sidebar-panel-active">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <p class="site-author-name" itemprop="name">renzheng</p>
              <p class="site-description motion-element" itemprop="description"></p>
          </div>

          
            <nav class="site-state motion-element">
              
                <div class="site-state-item site-state-posts">
                
                  <a href="/archives/">
                
                    <span class="site-state-item-count">8</span>
                    <span class="site-state-item-name">日志</span>
                  </a>
                </div>
              

              
                
                
                <div class="site-state-item site-state-categories">
                  <a href="/categories/index.html">
                    
                    
                      
                    
                      
                    
                      
                    
                      
                    
                    <span class="site-state-item-count">4</span>
                    <span class="site-state-item-name">分类</span>
                  </a>
                </div>
              

              
                
                
                <div class="site-state-item site-state-tags">
                  <a href="/tags/index.html">
                    
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                    <span class="site-state-item-count">6</span>
                    <span class="site-state-item-name">标签</span>
                  </a>
                </div>
              
            </nav>
          

          

          

          
          

          
          

          
            
          
          

        </div>
      </section>

      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2018</span>
  <span class="with-love" id="animate">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">renzheng</span>

  

  
</div>




  <div class="powered-by">由 <a class="theme-link" target="_blank" href="https://hexo.io">Hexo</a> 强力驱动 v3.7.1</div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">主题 &mdash; <a class="theme-link" target="_blank" href="https://theme-next.org">NexT.Mist</a> v6.3.0</div>




        








        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>


























  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=6.3.0"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=6.3.0"></script>



  
  

  

  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=6.3.0"></script>



  



	





  





  










  





  

  

  

  

  
  

  

  

  

  

  

</body>
</html>
