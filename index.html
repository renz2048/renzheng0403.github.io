<!DOCTYPE html>












  


<html class="theme-next mist use-motion" lang="zh-CN">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2"/>
<meta name="theme-color" content="#222">












<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />






















<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=6.3.0" rel="stylesheet" type="text/css" />


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=6.3.0">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=6.3.0">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=6.3.0">


  <link rel="mask-icon" href="/images/logo.svg?v=6.3.0" color="#222">









<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Mist',
    version: '6.3.0',
    sidebar: {"position":"left","display":"post","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: false,
    fastclick: false,
    lazyload: false,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>


  




  <meta property="og:type" content="website">
<meta property="og:title" content="renz">
<meta property="og:url" content="https://renzheng0403.github.io/index.html">
<meta property="og:site_name" content="renz">
<meta property="og:locale" content="zh-CN">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="renz">






  <link rel="canonical" href="https://renzheng0403.github.io/"/>



<script type="text/javascript" id="page.configurations">
  CONFIG.page = {
    sidebar: "",
  };
</script>

  <title>renz</title>
  









  <noscript>
  <style type="text/css">
    .use-motion .motion-element,
    .use-motion .brand,
    .use-motion .menu-item,
    .sidebar-inner,
    .use-motion .post-block,
    .use-motion .pagination,
    .use-motion .comments,
    .use-motion .post-header,
    .use-motion .post-body,
    .use-motion .collection-title { opacity: initial; }

    .use-motion .logo,
    .use-motion .site-title,
    .use-motion .site-subtitle {
      opacity: initial;
      top: initial;
    }

    .use-motion {
      .logo-line-before i { left: initial; }
      .logo-line-after i { right: initial; }
    }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-CN">

  
  
    
  

  <div class="container sidebar-position-left 
  page-home">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">renz</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
    
      
        <p class="site-subtitle">what's past is prologue</p>
      
    
  </div>

  <div class="site-nav-toggle">
    <button aria-label="切换导航栏">
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>



<nav class="site-nav">
  
    <ul id="menu" class="menu">
      
        
        
        
          
          <li class="menu-item menu-item-home menu-item-active">
    <a href="/" rel="section">
      <i class="menu-item-icon fa fa-fw fa-home"></i> <br />首页</a>
  </li>
        
        
        
          
          <li class="menu-item menu-item-about">
    <a href="/about/" rel="section">
      <i class="menu-item-icon fa fa-fw fa-user"></i> <br />关于</a>
  </li>
        
        
        
          
          <li class="menu-item menu-item-tags">
    <a href="/tags/" rel="section">
      <i class="menu-item-icon fa fa-fw fa-tags"></i> <br />标签</a>
  </li>
        
        
        
          
          <li class="menu-item menu-item-categories">
    <a href="/categories/" rel="section">
      <i class="menu-item-icon fa fa-fw fa-th"></i> <br />分类</a>
  </li>
        
        
        
          
          <li class="menu-item menu-item-archives">
    <a href="/archives/" rel="section">
      <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />归档</a>
  </li>

      
      
    </ul>
  

  
    

  

  
</nav>



  



</div>
    </header>

    


    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          
          <div id="content" class="content">
            
  <section id="posts" class="posts-expand">
    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://renzheng0403.github.io/2018/06/29/test/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="renzheng">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="renz">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/06/29/test/" itemprop="url">
                  md module
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">

            
            
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              

              
                
              

              <time title="创建时间：2018-06-29 23:55:29" itemprop="dateCreated datePublished" datetime="2018-06-29T23:55:29+08:00">2018-06-29</time>
            

            
              

              
                
                <span class="post-meta-divider">|</span>
                

                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                
                  <span class="post-meta-item-text">更新于</span>
                
                <time title="修改时间：2018-06-30 00:52:27" itemprop="dateModified" datetime="2018-06-30T00:52:27+08:00">2018-06-30</time>
              
            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="下载"><a href="#下载" class="headerlink" title="下载"></a>下载</h1><p>用于测试pdf文件的阅览与下载<br>在source文件夹下新建download文件夹用于存放待下载文件<br><a href="/download/test.pdf">test.pdf</a></p>
<h1 id="分类和标签"><a href="#分类和标签" class="headerlink" title="分类和标签"></a>分类和标签</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">categories:</span><br><span class="line">- Diary</span><br><span class="line">tags:</span><br><span class="line">- PS3</span><br><span class="line">- Games</span><br></pre></td></tr></table></figure>
<h1 id="搜索"><a href="#搜索" class="headerlink" title="搜索"></a>搜索</h1><p>TODO</p>
<h1 id="首页预览"><a href="#首页预览" class="headerlink" title="首页预览"></a>首页预览</h1><p>TODO</p>

          
        
      
    </div>

    

    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://renzheng0403.github.io/2018/06/07/nmap-ssl-ccs-injection脚本解析/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="renzheng">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="renz">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/06/07/nmap-ssl-ccs-injection脚本解析/" itemprop="url">
                  nmap ssl-ccs-injection脚本分析
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">

            
            
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              

              
                
              

              <time title="创建时间：2018-06-07 19:47:00" itemprop="dateCreated datePublished" datetime="2018-06-07T19:47:00+08:00">2018-06-07</time>
            

            
              

              
                
                <span class="post-meta-divider">|</span>
                

                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                
                  <span class="post-meta-item-text">更新于</span>
                
                <time title="修改时间：2018-06-30 00:43:29" itemprop="dateModified" datetime="2018-06-30T00:43:29+08:00">2018-06-30</time>
              
            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/nmap/" itemprop="url" rel="index"><span itemprop="name">nmap</span></a></span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="代码分析"><a href="#代码分析" class="headerlink" title="代码分析"></a>代码分析</h1><h2 id="require"><a href="#require" class="headerlink" title="require"></a>require</h2><p>nmap:与Nmap内部接口。</p>
<p>shortport:建立短portrules的函数</p>
<p>stdnse:标准的Nmap脚本引擎功能。 该模块包含各种方便的功能，这些模块功能太小而无法证明自己。</p>
<p>table:将输出排列成表格。</p>
<p>vulns:漏洞管理功能。</p>
<p>tls</p>
<h2 id="description"><a href="#description" class="headerlink" title="description"></a>description</h2><h3 id="CCS-Injection-vulnerability-CVE-2014-0224"><a href="#CCS-Injection-vulnerability-CVE-2014-0224" class="headerlink" title="CCS Injection vulnerability(CVE-2014-0224)"></a>CCS Injection vulnerability(CVE-2014-0224)</h3><p><a href="http://ccsinjection.lepidum.co.jp/blog/2014-06-05/CCS-Injection-en/index.html" target="_blank" rel="noopener">How I discovered CCS Injection Vulnerability (CVE-2014-0224)</a></p>
<h3 id="脚本流程"><a href="#脚本流程" class="headerlink" title="脚本流程"></a>脚本流程</h3><p>脚本发送一个失序的<code>ChangeCipherSpec</code>信息，检查服务器是否返回<code>UNEXPECTED_MESSAGE</code>警告字段。 由于未修复该漏洞的服务器只会接受此消息，因此CCS数据包将发送两次，以强制服务器发出警报。 如果警报类型与“UNEXPECTED_MESSAGE”不同，我们可以得出结论，服务器容易受影响。</p>
<h2 id="function-test-ccs-injection"><a href="#function-test-ccs-injection" class="headerlink" title="function test_ccs_injection"></a>function test_ccs_injection</h2><h3 id="向目标服务器发送Client-Hello"><a href="#向目标服务器发送Client-Hello" class="headerlink" title="向目标服务器发送Client Hello"></a>向目标服务器发送Client Hello</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">s:send(hello)</span><br></pre></td></tr></table></figure>
<p>检测发送状态，若失败返回错误信息<code>Couldn&#39;t send Client Hello: err</code>，<code>err</code>为s:send返回的err信息。</p>
<h3 id="读取回复"><a href="#读取回复" class="headerlink" title="读取回复"></a>读取回复</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">-- 判断是否是提示超时</span><br><span class="line">tls.record_buffer(s, response, i)</span><br><span class="line"></span><br><span class="line">tls.record_read(response, i)</span><br><span class="line"></span><br><span class="line">-- 循环record</span><br><span class="line">  -- 判断record.type == “handshake&quot;</span><br><span class="line">    -- 判断body.type == &quot;server_hello_done&quot;</span><br><span class="line">      stdnse.debug1(&quot;Handshake completed (%s)&quot;, version)</span><br></pre></td></tr></table></figure>
<h3 id="重复发送change-cipher-spec"><a href="#重复发送change-cipher-spec" class="headerlink" title="重复发送change_cipher_spec"></a>重复发送change_cipher_spec</h3><h4 id="change-cipher-spec消息"><a href="#change-cipher-spec消息" class="headerlink" title="change_cipher_spec消息"></a>change_cipher_spec消息</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ccs = tls.record_write(&quot;change_cipher_spec&quot;, version, &quot;\x01&quot;)</span><br></pre></td></tr></table></figure>
<h4 id="发送第一个ccs消息"><a href="#发送第一个ccs消息" class="headerlink" title="发送第一个ccs消息"></a>发送第一个ccs消息</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">s:send(ccs)</span><br></pre></td></tr></table></figure>
<h4 id="发送第二个ccs消息"><a href="#发送第二个ccs消息" class="headerlink" title="发送第二个ccs消息"></a>发送第二个ccs消息</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">s:send(ccs)</span><br></pre></td></tr></table></figure>
<h4 id="读取警告信息"><a href="#读取警告信息" class="headerlink" title="读取警告信息"></a>读取警告信息</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vulnerable = alert_unexpected_message(s)</span><br></pre></td></tr></table></figure>
<h2 id="function-alert-unexpected-message-s"><a href="#function-alert-unexpected-message-s" class="headerlink" title="function alert_unexpected_message(s)"></a>function alert_unexpected_message(s)</h2><p>buffer = tls.record_buffer(s, buffer, 1)</p>
<p>record = tls.record_read(buffer, 1)</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">if record.type ~= &quot;alert&quot; then</span><br><span class="line">    -- VULNERABLE 标记，预期中的alert record</span><br><span class="line">    return true,true</span><br><span class="line">  end</span><br><span class="line"></span><br><span class="line">  for _, body in ipairs(record.body) do</span><br><span class="line">    if body.level == &quot;fatal&quot; and body.description == &quot;unexpected_message&quot; then</span><br><span class="line">      return true,false</span><br><span class="line">    end</span><br><span class="line">  end</span><br></pre></td></tr></table></figure>
<h2 id="action-function-host-port"><a href="#action-function-host-port" class="headerlink" title="action = function(host, port)"></a>action = function(host, port)</h2><p>对<code>tls.PROTOCOLS</code>迭代</p>
<p>  local vulnerable, err = test_ccs_injection(host, port, tls_version)</p>
<h1 id="检测"><a href="#检测" class="headerlink" title="检测"></a>检测</h1><h2 id="对自建易受攻击环境的检测"><a href="#对自建易受攻击环境的检测" class="headerlink" title="对自建易受攻击环境的检测"></a>对自建易受攻击环境的检测</h2><p>客户端执行nmap：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">renz@ubuntuserver17:~$ nmap -p 443 --script ssl-ccs-injection 192.168.80.211</span><br><span class="line"></span><br><span class="line">Starting Nmap 7.50 ( https://nmap.org ) at 2018-06-08 11:52 CST</span><br><span class="line">Nmap scan report for 192.168.80.211</span><br><span class="line">Host is up (0.00042s latency).</span><br><span class="line"></span><br><span class="line">PORT    STATE SERVICE</span><br><span class="line">443/tcp open  https</span><br><span class="line">| ssl-ccs-injection:</span><br><span class="line">|   VULNERABLE:</span><br><span class="line">|   SSL/TLS MITM vulnerability (CCS Injection)</span><br><span class="line">|     State: VULNERABLE</span><br><span class="line">|     Risk factor: High</span><br><span class="line">|       OpenSSL before 0.9.8za, 1.0.0 before 1.0.0m, and 1.0.1 before 1.0.1h</span><br><span class="line">|       does not properly restrict processing of ChangeCipherSpec messages,</span><br><span class="line">|       which allows man-in-the-middle attackers to trigger use of a zero</span><br><span class="line">|       length master key in certain OpenSSL-to-OpenSSL communications, and</span><br><span class="line">|       consequently hijack sessions or obtain sensitive information, via</span><br><span class="line">|       a crafted TLS handshake, aka the &quot;CCS Injection&quot; vulnerability.</span><br><span class="line">|</span><br><span class="line">|     References:</span><br><span class="line">|       http://www.openssl.org/news/secadv_20140605.txt</span><br><span class="line">|       https://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2014-0224</span><br><span class="line">|_      http://www.cvedetails.com/cve/2014-0224</span><br><span class="line"></span><br><span class="line">Nmap done: 1 IP address (1 host up) scanned in 0.26 seconds</span><br></pre></td></tr></table></figure></p>
<p>客户端抓包:<code>ssldump -i eth0</code>：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line">10 2  0.0019 (0.0015)  S&gt;C  Handshake</span><br><span class="line">      ServerHello</span><br><span class="line">        Version 3.1</span><br><span class="line">        session_id[32]=</span><br><span class="line">          b6 d5 f5 96 08 bc c0 6c 1c 31 5b df 34 11 e5 60</span><br><span class="line">          d4 61 d1 da f1 c3 78 b4 d1 64 d3 df 00 48 e7 71</span><br><span class="line">        cipherSuite         TLS_RSA_WITH_3DES_EDE_CBC_SHA</span><br><span class="line">        compressionMethod                   NULL</span><br><span class="line">10 3  0.0019 (0.0000)  S&gt;C  Handshake</span><br><span class="line">      Certificate</span><br><span class="line">10 4  0.0019 (0.0000)  S&gt;C  Handshake</span><br><span class="line">      ServerHelloDone</span><br><span class="line">10 5  0.0022 (0.0002)  C&gt;S  ChangeCipherSpec</span><br><span class="line">10 6  0.0426 (0.0404)  C&gt;S  ChangeCipherSpec</span><br><span class="line">10 7  0.0429 (0.0002)  S&gt;C  Alert</span><br><span class="line">    level           fatal</span><br><span class="line">    value           decryption_failed</span><br><span class="line">10    0.0430 (0.0001)  C&gt;S  TCP FIN</span><br><span class="line">10    0.0431 (0.0001)  S&gt;C  TCP FIN</span><br></pre></td></tr></table></figure></p>
<p><strong>107行未检测到<code>unexpected_message</code>表明未修复该漏洞</strong>。</p>
<h2 id="对自建不受攻击环境的检测"><a href="#对自建不受攻击环境的检测" class="headerlink" title="对自建不受攻击环境的检测"></a>对自建不受攻击环境的检测</h2><p>客户端执行nmap：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">renz@ubuntuserver17:~$ nmap -p 443 --script ssl-ccs-injection 192.168.80.215</span><br><span class="line"></span><br><span class="line">Starting Nmap 7.50 ( https://nmap.org ) at 2018-06-08 11:39 CST</span><br><span class="line">Nmap scan report for 192.168.80.215</span><br><span class="line">Host is up (0.00046s latency).</span><br><span class="line"></span><br><span class="line">PORT    STATE SERVICE</span><br><span class="line">443/tcp open  https</span><br><span class="line"></span><br><span class="line">Nmap done: 1 IP address (1 host up) scanned in 0.22 seconds</span><br></pre></td></tr></table></figure></p>
<p>客户端抓包：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">78 2  0.0010 (0.0005)  S&gt;C  Handshake</span><br><span class="line">      ServerHello</span><br><span class="line">        Version 3.3</span><br><span class="line">        session_id[32]=</span><br><span class="line">          57 bc 8c 2c ba 85 97 52 1f 0e 68 5c 56 c1 21 96</span><br><span class="line">          88 db a6 b6 8c 4d b4 4b eb 36 e1 a7 b8 29 6d 57</span><br><span class="line">        cipherSuite         TLS_RSA_WITH_AES_256_CBC_SHA</span><br><span class="line">        compressionMethod                   NULL</span><br><span class="line">78 3  0.0010 (0.0000)  S&gt;C  Handshake</span><br><span class="line">      Certificate</span><br><span class="line">78 4  0.0010 (0.0000)  S&gt;C  Handshake</span><br><span class="line">      ServerHelloDone</span><br><span class="line">78 5  0.0013 (0.0003)  C&gt;S  ChangeCipherSpec</span><br><span class="line">78 6  0.0016 (0.0002)  S&gt;C  Alert</span><br><span class="line">    level           fatal</span><br><span class="line">    value           unexpected_message</span><br><span class="line">78 7  0.0016 (0.0000)  C&gt;S  ChangeCipherSpec</span><br><span class="line">78    0.0016 (0.0000)  S&gt;C  TCP FIN</span><br><span class="line">78    0.0018 (0.0001)  C&gt;S  TCP FIN</span><br></pre></td></tr></table></figure></p>
<p><strong>78行检测到<code>unexpected_message</code>表明已修复该漏洞</strong>。</p>
<h1 id="利用漏洞攻击"><a href="#利用漏洞攻击" class="headerlink" title="利用漏洞攻击"></a>利用漏洞攻击</h1><p>能力有限，虽然手头有易被攻击的环境，但仍没有什么可行的办法以己之矛攻己之盾。是不是说自己作为中间人，成功诱导c/s双方使用弱加密套件，自己这边穷举算出密钥的可能性就大了。<br>我果然最后都没能搞出。<br>看了以下几篇文章推荐给大家，如果有什么可行性高的办法请一定分享。<br><a href="https://www.imperialviolet.org/2014/06/05/earlyccs.html" target="_blank" rel="noopener">早期ChangeCipherSpec攻击</a><br><a href="http://ccsinjection.lepidum.co.jp/blog/2014-06-05/CCS-Injection-en/index.html" target="_blank" rel="noopener">How I discovered CCS Injection Vulnerability (CVE-2014-0224)</a></p>
<h2 id="使用1-0-1h之前版本的openssl进行ssl握手"><a href="#使用1-0-1h之前版本的openssl进行ssl握手" class="headerlink" title="使用1.0.1h之前版本的openssl进行ssl握手"></a>使用1.0.1h之前版本的openssl进行ssl握手</h2><p>进行这样一个测试，我觉得我需要两个ubuntu，作为服务端的ubuntu安装openssl-1.0.1g，并运行命令openssl s_server，客户端运行nmap。<br>或者通过gdb来运行openssl s_server来查看openssl如何接受ChangeCipherSpec。</p>
<p>handshark flow：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">Client                                                Server</span><br><span class="line"></span><br><span class="line">ClientHello                   --------&gt;</span><br><span class="line">                                                 ServerHello</span><br><span class="line">                                                Certificate*</span><br><span class="line">                                          ServerKeyExchange*</span><br><span class="line">                                         CertificateRequest*</span><br><span class="line">                              &lt;--------      ServerHelloDone</span><br><span class="line">Certificate*</span><br><span class="line">ClientKeyExchange</span><br><span class="line">CertificateVerify*</span><br><span class="line">[ChangeCipherSpec]</span><br><span class="line">Finished                      --------&gt;</span><br><span class="line">                                          [ChangeCipherSpec]</span><br><span class="line">                              &lt;--------             Finished</span><br><span class="line">Application Data              &lt;-------&gt;     Application Data</span><br></pre></td></tr></table></figure></p>

          
        
      
    </div>

    

    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://renzheng0403.github.io/2018/06/07/nmap脚本写作教程/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="renzheng">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="renz">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/06/07/nmap脚本写作教程/" itemprop="url">
                  nmap脚本写作教程
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">

            
            
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              

              
                
              

              <time title="创建时间：2018-06-07 18:53:00" itemprop="dateCreated datePublished" datetime="2018-06-07T18:53:00+08:00">2018-06-07</time>
            

            
              

              
                
                <span class="post-meta-divider">|</span>
                

                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                
                  <span class="post-meta-item-text">更新于</span>
                
                <time title="修改时间：2018-06-30 00:43:41" itemprop="dateModified" datetime="2018-06-30T00:43:41+08:00">2018-06-30</time>
              
            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/nmap/" itemprop="url" rel="index"><span itemprop="name">nmap</span></a></span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>原文：<a href="https://nmap.org/book/nse-tutorial.html" target="_blank" rel="noopener">Script Writing Tutorial</a></p>
<blockquote>
<p>事实上，在你看这篇译文之前，我必须要解释两点</p>
<ol>
<li>按照这篇译文写出的代码并没有发挥作用</li>
<li>你可以通过这篇文章了解到script的框架</li>
</ol>
</blockquote>
<p>假设您想要从identification服务器提取信息以确定侦听TCP端口的进程的所有者。 这不是identd的目的（它是为了查询传出连接的所有者，而不是监听守护进程），但许多identd服务器都允许它。Nmap曾经拥有这种功能（称为ident扫描），但在过渡到新的扫描引擎架构时被删除。 identd使用的协议非常简单，但仍然太复杂，无法处理Nmap的版本检测语言。 首先，连接到标识服务器并发送<port-on-server>，<port-on-client>格式的查询，并以换行符结尾。 然后，服务器应该使用包含服务器端口，客户端端口，响应类型和地址信息的字符串进行响应。 如果出现错误，地址信息将被省略。 更多细节可在<a href="https://www.rfc-editor.org/rfc/rfc1413.txt" target="_blank" rel="noopener">RFC 1413</a>中找到，但这种描述对我们的目的来说已经足够了。该协议不能用Nmap的版本检测语言建模，原因有两个。 首先，您需要知道连接的本地端口和远程端口。 版本检测不提供此数据。 第二个更严重的障碍是，您需要两个打开的连接到目标 - 一个连接到识别服务器，一个连接到您希望查询的侦听端口。 NSE很容易克服这两种障碍。</port-on-client></port-on-server></p>
<p>脚本的解剖部分在<a href="https://nmap.org/book/nse-script-format.html" target="_blank" rel="noopener">脚本格式</a>一节中进行了描述。 在本节中，我们将介绍如何使用所描述的结构。</p>
<h1 id="The-Head"><a href="#The-Head" class="headerlink" title="The Head"></a>The Head</h1><p>脚本的head本质上是它的元信息。包含下列字段：<code>description</code>,<code>categories</code>,<code>dependencies</code>,<code>author</code>,<code>license</code>以及初始NSEDoc信息，例如用法，参数和输出标签<a href="https://nmap.org/book/nsedoc.html" target="_blank" rel="noopener">参考编写脚本文档一节</a>。</p>
<p><code>description</code>应包含一段或更多段描述脚本的功能。 如果有关脚本结果的任何信息可能会混淆或误导用户，并且您无法通过改进脚本或结果文本来消除此问题，则应将其记录在<code>description</code>中。 如果有多个段落，第一个在必要时用作简短摘要。 确保第一段可以作为一个独立的摘要。 这个描述很简短，因为它是一个如此简单的脚本：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">description = [[</span><br><span class="line">Attempts to find the owner of an open TCP port by querying an auth</span><br><span class="line">(identd - port 113) daemon which must also be open on the target system.</span><br><span class="line">]]</span><br></pre></td></tr></table></figure>
<p>接下来是NSEDoc信息。 此脚本缺少常见的@usage和@args标记，因为它非常简单，但它确实有一个NSEDoc @output标记：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">---</span><br><span class="line">--@output</span><br><span class="line">-- 21/tcp   open     ftp       ProFTPD 1.3.1</span><br><span class="line">-- |_ auth-owners: nobody</span><br><span class="line">-- 22/tcp   open     ssh       OpenSSH 4.3p2 Debian 9etch2 (protocol 2.0)</span><br><span class="line">-- |_ auth-owners: root</span><br><span class="line">-- 25/tcp   open     smtp      Postfix smtpd</span><br><span class="line">-- |_ auth-owners: postfix</span><br><span class="line">-- 80/tcp   open     http      Apache httpd 2.0.61 ((Unix) PHP/4.4.7 ...)</span><br><span class="line">-- |_ auth-owners: dhapache</span><br><span class="line">-- 113/tcp  open     auth?</span><br><span class="line">-- |_ auth-owners: nobody</span><br><span class="line">-- 587/tcp  open     submission Postfix smtpd</span><br><span class="line">-- |_ auth-owners: postfix</span><br><span class="line">-- 5666/tcp open     unknown</span><br><span class="line">-- |_ auth-owners: root</span><br></pre></td></tr></table></figure>
<p>接下来是<code>author</code>,<code>license</code>,<code>categories</code>标签。 此脚本属于<code>safe</code>，因为我们没有将该服务用于任何不适用的内容。 由于此脚本是默认运行的脚本，因此它也位于<code>default</code>类别中。 以下是上下文中的变量：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">author = &quot;Diman Todorov&quot;</span><br><span class="line"></span><br><span class="line">license = &quot;Same as Nmap--See https://nmap.org/book/man-legal.html&quot;</span><br><span class="line"></span><br><span class="line">categories = &#123;&quot;default&quot;, &quot;safe&quot;&#125;</span><br></pre></td></tr></table></figure>
<h1 id="The-Rule"><a href="#The-Rule" class="headerlink" title="The Rule"></a>The Rule</h1><p><code>rule</code>是一个Lua方法，决定跳过还是执行脚本动作。 该决定通常基于规则的类型以及传递给它的主机和端口信息。 prerule或postrule将始终评估为true。 在识别脚本的情况下，它比这稍微复杂一些。 要决定是否针对给定端口运行识别脚本，我们需要知道目标机器上是否存在运行auth服务器。 换句话说，只有在当前扫描的TCP端口打开并且TCP端口113也打开的情况下，脚本才能运行。 现在我们将依赖识别服务器在TCP端口113上侦听的事实。不幸的是，NSE只给我们提供关于当前扫描端口的信息。</p>
<p>要知道端口113是否打开，我们使用nmap.get_port_state函数。 如果未扫描auth端口，则get_port_state函数返回nil。 所以我们检查表不是零。 我们还检查两个端口是否处于打开状态。 如果是这种情况，则执行该动作，否则我们跳过该动作。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">portrule = function(host, port)</span><br><span class="line">	local auth_port = &#123; number=113, protocol=&quot;tcp&quot; &#125;</span><br><span class="line">	local identd = nmap.get_port_state(host, auth_port)</span><br><span class="line"></span><br><span class="line">	return identd ~= nil</span><br><span class="line">		and identd.state == &quot;open&quot;</span><br><span class="line">		and port.protocol == &quot;tcp&quot;</span><br><span class="line">		and port.state == &quot;open&quot;</span><br><span class="line">end</span><br></pre></td></tr></table></figure>
<h1 id="The-Action"><a href="#The-Action" class="headerlink" title="The Action"></a>The Action</h1><p>最后我们实现了实际的功能！ 该脚本首先连接到我们期望找到标识服务器的端口，然后它将连接到我们想要获取信息的端口。 这样做首先通过调用nmap.new_socket创建两个套接字选项。 接下来我们定义一个错误处理catch函数，如果检测到失败，它会关闭这些套接字。 在这一点上，我们可以安全地使用诸如打开，关闭，发送和接收之类的对象方法来在网络套接字上操作。 在这种情况下，我们称connect为连接。 NSE的异常处理机制用于避免过多的错误处理代码。 我们只需在尝试调用中打包网络调用，如果出现任何问题，我们会调用catch函数。</p>
<p>如果两个连接成功，我们构造一个查询字符串并解析响应。 如果我们收到满意的答复，我们会返回检索到的信息。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">action = function(host, port)</span><br><span class="line">        local owner = &quot;&quot;</span><br><span class="line"></span><br><span class="line">        local client_ident = nmap.new_socket()</span><br><span class="line">        local client_service = nmap.new_socket()</span><br><span class="line"></span><br><span class="line">        local catch = function()</span><br><span class="line">                client_ident:close()</span><br><span class="line">                client_service:close()</span><br><span class="line">        end</span><br><span class="line"></span><br><span class="line">        local try = nmap.new_try(catch)</span><br><span class="line"></span><br><span class="line">        try(client_ident:connect(host.ip, 113))</span><br><span class="line">        try(client_service:connect(host.ip, port.number))</span><br><span class="line"></span><br><span class="line">        local localip, localport, remoteip, remoteport =</span><br><span class="line">                try(client_service:get_info())</span><br><span class="line"></span><br><span class="line">        local request = port.number .. &quot;, &quot; .. localport .. &quot;\r\n&quot;</span><br><span class="line"></span><br><span class="line">        try(client_ident:send(request))</span><br><span class="line"></span><br><span class="line">        owner = try(client_ident:receive_lines(1))</span><br><span class="line"></span><br><span class="line">        if string.match(owner, &quot;ERROR&quot;) then </span><br><span class="line">                owner = nil</span><br><span class="line">        else</span><br><span class="line">                owner = string.match(owner,</span><br><span class="line">                        &quot;%d+%s*,%s*%d+%s*:%s*USERID%s*:%s*.+%s*:%s*(.+)\r?\n&quot;)</span><br><span class="line">        end</span><br><span class="line"></span><br><span class="line">        try(client_ident:close())</span><br><span class="line">        try(client_service:close())</span><br><span class="line"></span><br><span class="line">        return owner</span><br><span class="line">end</span><br></pre></td></tr></table></figure>
<p>请注意，因为我们知道远程端口存储在port.number中，所以我们可以忽略client_service的最后两个返回值：get_info（），如下所示：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">local localip, localport = try(client_service:get_info())</span><br></pre></td></tr></table></figure>
<p>在这个例子中，如果服务响应错误，我们会安静地退出。 这是通过将nil分配给将返回的所有者变量来完成的。 NSE脚本通常只在成功时才会返回消息，因此它们不会用无意义的警报泛滥用户。</p>

          
        
      
    </div>

    

    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://renzheng0403.github.io/2017/12/20/Tun-Tap接口教材/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="renzheng">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="renz">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2017/12/20/Tun-Tap接口教材/" itemprop="url">
                  TUN-TAP接口教程
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">

            
            
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              

              
                
              

              <time title="创建时间：2017-12-20 01:00:00" itemprop="dateCreated datePublished" datetime="2017-12-20T01:00:00+08:00">2017-12-20</time>
            

            
              

              
                
                <span class="post-meta-divider">|</span>
                

                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                
                  <span class="post-meta-item-text">更新于</span>
                
                <time title="修改时间：2018-06-30 00:52:25" itemprop="dateModified" datetime="2018-06-30T00:52:25+08:00">2018-06-30</time>
              
            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/vpn/" itemprop="url" rel="index"><span itemprop="name">vpn</span></a></span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p><a href="http://backreference.org/2010/03/26/tuntap-interface-tutorial/" target="_blank" rel="noopener">原文</a></p>
<p><em>前言：请注意，这里提供的代码仅用于演示目的。 如果你想要认真，你必须使它更健壮，并与其他代码整合。 而且，这个描述绝不是关于这个问题的明确的参考，而是我实验的结果。 请报告您在代码或本文中找到的任何bug或错误。 谢谢。</em></p>
<p>链接到文章中描述的源码tarball：<a href="http://backreference.org/wp-content/uploads/2010/03/simpletun.tar.bz2" target="_blank" rel="noopener">simpletun</a>。</p>
<hr>
<p><strong>18/07/2010更新</strong>：感谢<a href="http://blog.bofh.it/debian/id_379" target="_blank" rel="noopener">这篇文章</a>，现在我已经知道了最新版本的iproute2可以（终于）创建tun/tap设备，尽管到现在都没有完整的说明文档。再也不用为了创建tun设备，而安装tunctl（UML utilities）或OpenVPN了。以下是iproute2-2.6.34：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"># ip tuntap help</span><br><span class="line">Usage: ip tuntap &#123; add | del &#125; [ dev PHYS_DEV ] </span><br><span class="line">          [ mode &#123; tun | tap &#125; ] [ user USER ] [ group GROUP ]</span><br><span class="line">          [ one_queue ] [ pi ] [ vnet_hdr ]</span><br><span class="line"></span><br><span class="line">Where: USER  := &#123; STRING | NUMBER &#125;</span><br><span class="line">       GROUP := &#123; STRING | NUMBER &#125;</span><br></pre></td></tr></table></figure></p>
<hr>
<p><strong>Tun/tap interfaces</strong>是Linux（也可能是其他类UNIX操作系统）提供的一种功能，可以执行<em>userspace networking</em>，也就是允许userspace程序查看原始网络流量（在ethernet或IP level）并像它一样执行任何操作。本文档试图解释在Linux下tun/tap接口是如何工作的，以及一些示例代码来演示它们的用法。</p>
<h1 id="工作原理"><a href="#工作原理" class="headerlink" title="工作原理"></a>工作原理</h1><p>Tun/tap interfaces是<em>software-only interfaces</em>，这意味着它们只存在于内核中，与常规网络接口不同，它们没有物理硬件组件（因此没有物理“线”连接到它们）。当内核决定发送数据在这个接口（而不是发送到接口的某个用户空间程序），tun/tap就像一个普通的网络接口一样（使用具体程序见下文）。当程序连接到tun/tap接口时，它会得到一个特殊的文件描述符，从中读取接口发送的数据。以类似的方式，程序可以写入这个特殊的描述符，数据（必须正确格式化，我们将会看到）将作为tun/tap接口的输入。对于内核来说，看起来像tun/tap接口正在从“wire”接收数据。<br><img src="https://upload-images.jianshu.io/upload_images/5278708-f40ce31882689cd5.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="tun-tap.png"></p>
<p>tap接口和tun接口的区别在于tap接口输出或接收完整的以太网帧，而tun接口输出或接收原始IP数据包（并且内核没有添加以太网报头）。在创建接口时，用一个标志指定接口的功能是像tun接口还是像tap接口一样。</p>
<p>接口可以是<strong>暂时的</strong>，也就是说它是由同一个程序创建，使用和销毁的; 当程序终止时，即使不明确销毁接口，接口也不复存在。 另一个选择（我更喜欢）是使接口<strong>持久化</strong>; 在这种情况下，专用程序（如tunctl或openvpn –mktun）创建它，正常的程序也可以附加其上; 当他们这样做的时候，他们必须使用相同类型（tun或tap）来创建接口进行连接，否则他们将无法连接。 我们将看到代码中是如何完成的。</p>
<p>一旦tun/tap接口就位，它可以像其他任何接口一样使用，这意味着可以分配IP地址，分析其流量，创建防火墙规则，建立指向它的路由等。</p>
<p>有了这些知识，让我们试着看看我们如何使用tun/tap接口以及如何使用它。</p>
<h1 id="创建虚拟接口"><a href="#创建虚拟接口" class="headerlink" title="创建虚拟接口"></a>创建虚拟接口</h1><p>创建全新interface和重新连接到持久interface的代码本质上是相同的; 不同之处在于前者必须以root身份运行（更确切地说，具有<strong>CAP_NET_ADMIN</strong>功能的用户），而后者则可以由普通用户在满足某些条件的情况下运行。 我们先从创建一个新的interface开始。</p>
<p>首先，设备<strong>/dev/net/tun</strong>必须以read/write的方式打开。 该设备也被称为<strong>克隆设备</strong>，它是创建任何tun/tap虚拟接口的起点。 操作（与任何open()调用一样）返回一个文件描述符。 但是这还不足以开始使用它与界面进行通信。</p>
<p>创建接口的下一步是使用一个特殊的<strong>ioctl()</strong>系统调用，它的参数包含上一步获得的文件描述符、<strong>TUNSETIFF</strong>常量，以及一个指向包含描述虚拟接口（基本上是 名称和所需的操作模式 - tun/tap）的结构体。 作为一种变体，虚拟接口的名称可以不指定，在这种情况下，内核将通过按序分配来为设备选择一个名称（例如，如果tap2已经存在，内核将尝试 分配tap3，等等）。 所有这些都必须由root用户来完成（或者由具有CAP_NET_ADMIN功能的用户来完成 - 我不会再重复一遍;假设它适用于我所说的“必须由root运行”）。<br>如果ioctl()成功，则创建虚拟接口，并且我们所拥有的文件描述符现在与其关联，并可用于通信。</p>
<p>针对接口有两种使用情形。 该程序可以立即开始使用接口（可能在此之前至少配置一个IP地址），当程序完成时，终止并销毁接口。 另一个选择是发出一些其他特殊的ioctl()调用来使接口持久化，停止的时候将其留在其他程序附加的地方。 例如，这就是像<code>tunctl</code>或<code>openvpn --mktun</code>这样的程序。 这些程序通常还可以选择将虚拟接口的所有权设置为非root用户和/或组，所以以非root用户身份运行但具有适当权限的程序可以稍后附加到接口。 我们将回到这个下面。</p>
<p>用于创建虚拟接口的基本代码显示在内核源代码树的<strong>Documentation/networking/tuntap.txt</strong>文件中。 修改一下，我们可以编写一个准系统函数来创建一个虚拟接口：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;linux /if.h&gt;</span><br><span class="line">#include &lt;linux /if_tun.h&gt;</span><br><span class="line"></span><br><span class="line">int tun_alloc(char *dev, int flags) &#123;</span><br><span class="line"></span><br><span class="line">  struct ifreq ifr;</span><br><span class="line">  int fd, err;</span><br><span class="line">  char *clonedev = &quot;/dev/net/tun&quot;;</span><br><span class="line"></span><br><span class="line">  /* 函数采用的参数：</span><br><span class="line">   *</span><br><span class="line">   * char *dev: 接口的名称（或 &apos;\0&apos;）。 必须有足够的空间来保存接口名称</span><br><span class="line">   * int flags: 接口标志 (eg, IFF_TUN etc.)</span><br><span class="line">   */</span><br><span class="line"></span><br><span class="line">   /* open克隆设备 */</span><br><span class="line">   if( (fd = open(clonedev, O_RDWR)) &lt; 0 ) &#123;</span><br><span class="line">     return fd;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   /* 初始化结构ifr或类型&quot;struct ifreq */</span><br><span class="line">   memset(&amp;ifr, 0, sizeof(ifr));</span><br><span class="line"></span><br><span class="line">   ifr.ifr_flags = flags;   /* IFF_TUN或IFF_TAP，也可能是IFF_NO_PI */</span><br><span class="line"></span><br><span class="line">   if (*dev) &#123;</span><br><span class="line">     /* 如果指定了设备名称，则将其放入结构中；</span><br><span class="line">      * 否则，内核将尝试分配指定类型的&quot;next&quot;设备</span><br><span class="line">      */</span><br><span class="line">     strncpy(ifr.ifr_name, dev, IFNAMSIZ);</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   /* 尝试创建设备 */</span><br><span class="line">   if( (err = ioctl(fd, TUNSETIFF, (void *) &amp;ifr)) &lt; 0 ) &#123;</span><br><span class="line">     close(fd);</span><br><span class="line">     return err;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">  /* 如果创建成功，则将接口的名称写回变量“dev”，以便调用者知道它。</span><br><span class="line">   * 请注意，调用者必须在* dev中保留空间（请参阅下面的调用代码）</span><br><span class="line">   */</span><br><span class="line">  strcpy(dev, ifr.ifr_name);</span><br><span class="line"></span><br><span class="line">  /* 调用者用来与虚拟接口连接的特殊文件描述符</span><br><span class="line">   */</span><br><span class="line">  return fd;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><strong>tun_alloc()</strong>函数有两个参数：</p>
<ul>
<li><strong>char * dev</strong>包含接口的名称（例如，tap0，tun2等）。任何名字都可以使用，但是最好选择一个名字来表明它是哪种类型的接口。实际上，通常使用像tunX或tapX这样的名称。如果<code>*dev</code>是<code>&#39;\ 0&#39;</code>，内核将尝试创建所需类型的“第一个”可用接口（例如，tap0，但是如果已经存在的话，tap1等等）。</li>
<li><strong>int flags</strong>包含通知内核我们需要哪种接口的标志（tun或tap）。基本上，它可以取值为<strong>IFF_TUN</strong>来指示一个TUN设备（数据包中没有以太网报头），或者<strong>IFF_TAP</strong>来指示一个TAP设备（数据包中有以太网报头）。<br>另外，另一个标志<strong>IFF_NO_PI</strong>可以与基值进行或运算。 IFF_NO_PI告诉内核不提供数据包信息。 IFF_NO_PI的目的是告诉内核，数据包将是“纯”的IP数据包，没有添加字节。否则（如果IFF_NO_PI未设置），将在数据包的开头添加4个额外的字节（2个标志字节和2个协议字节）。 IFF_NO_PI不需要在接口创建和重新连接时间之间匹配。另外请注意，当使用Wireshark捕获接口上的流量时，这4个字节从不显示。</li>
</ul>
<p>程序可以使用下面的代码来创建一个设备：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">char tun_name[IFNAMSIZ];</span><br><span class="line">char tap_name[IFNAMSIZ];</span><br><span class="line">char *a_name;</span><br><span class="line"></span><br><span class="line">...</span><br><span class="line"></span><br><span class="line">strcpy(tun_name, &quot;tun1&quot;);</span><br><span class="line">tunfd = tun_alloc(tun_name, IFF_TUN);  /* tun接口 */</span><br><span class="line"></span><br><span class="line">strcpy(tap_name, &quot;tap44&quot;);</span><br><span class="line">tapfd = tun_alloc(tap_name, IFF_TAP);  /* tap接口 */</span><br><span class="line"></span><br><span class="line">a_name = malloc(IFNAMSIZ);</span><br><span class="line">a_name[0]=&apos;\0&apos;;</span><br><span class="line">tapfd = tun_alloc(a_name, IFF_TAP);    /* 内核自定义接口 */</span><br></pre></td></tr></table></figure></p>
<p>如前所述，程序可以按照其用途使用接口，也可以将接口设置为持久性（并可选地将所有权分配给特定的用户/组）。 如果是前者，那就没什么好说的了。 但是如果是后者，接下来我们将看到发生了什么。<br>两个额外可用的ioctl()通常一起使用。第一个系统调用可以设置（或删除）接口上的持久状态。第二个允许将接口的所有权分配给常规（非root）用户。 这两个功能在程序tunctl（UML实用程序的一部分）和openvpn –mktun（可能还有其他）中实现。看看tunctl代码，它更简单，记住它只创建tap接口，因为这些是linux用户模式使用的（为了清晰起见，代码被稍微编辑和简化）<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line">  /* 如果用户想要删除（使其非持久化）现有接口，则设置&quot;delete&quot;;</span><br><span class="line">   * 否则，用户将创建一个新的接口</span><br><span class="line">   */</span><br><span class="line">  if(delete) &#123;</span><br><span class="line">    /* 删除持久化状态 */</span><br><span class="line">    if(ioctl(tap_fd, TUNSETPERSIST, 0) &lt; 0)&#123;</span><br><span class="line">      perror(&quot;disabling TUNSETPERSIST&quot;);</span><br><span class="line">      exit(1);</span><br><span class="line">    &#125;</span><br><span class="line">    printf(&quot;Set &apos;%s&apos; nonpersistent\n&quot;, ifr.ifr_name);</span><br><span class="line">  &#125;</span><br><span class="line">  else &#123;</span><br><span class="line">    /* 在TUNSETGROUP之前模拟行为 */</span><br><span class="line">    if(owner == -1 &amp;&amp; group == -1) &#123;</span><br><span class="line">      owner = geteuid();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    if(owner != -1) &#123;</span><br><span class="line">      if(ioctl(tap_fd, TUNSETOWNER, owner) &lt; 0)&#123;</span><br><span class="line">        perror(&quot;TUNSETOWNER&quot;);</span><br><span class="line">        exit(1);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    if(group != -1) &#123;</span><br><span class="line">      if(ioctl(tap_fd, TUNSETGROUP, group) &lt; 0)&#123;</span><br><span class="line">        perror(&quot;TUNSETGROUP&quot;);</span><br><span class="line">        exit(1);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    if(ioctl(tap_fd, TUNSETPERSIST, 1) &lt; 0)&#123;</span><br><span class="line">      perror(&quot;enabling TUNSETPERSIST&quot;);</span><br><span class="line">      exit(1);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    if(brief)</span><br><span class="line">      printf(&quot;%s\n&quot;, ifr.ifr_name);</span><br><span class="line">    else &#123;</span><br><span class="line">      printf(&quot;Set &apos;%s&apos; persistent and owned by&quot;, ifr.ifr_name);</span><br><span class="line">      if(owner != -1)</span><br><span class="line">          printf(&quot; uid %d&quot;, owner);</span><br><span class="line">      if(group != -1)</span><br><span class="line">          printf(&quot; gid %d&quot;, group);</span><br><span class="line">      printf(&quot;\n&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  ...</span><br></pre></td></tr></table></figure></p>
<p>这些额外的ioctl()s仍然必须由root运行。但是现在我们拥有的是一个特定用户拥有的持久性接口，所以作为该用户运行的进程可以成功地连接到它。<br>如上所述，事实证明，（重新）附加到现有tun/tap接口的代码与用于创建它的代码相同;换句话说，可以再次使用tun_alloc（）。在这样做的时候，要取得成功，必然发生三件事情：</p>
<ul>
<li>该接口必须已经存在，并且由正试图连接的同一个用户所拥有（可能是持久的）</li>
<li>用户必须对<strong>/dev/net/tun</strong>具有读/写权限</li>
<li>提供的标志必须与用于创建接口的标志相匹配（例如，如果它是使用IFF_TUN创建的，那么在重新连接时必须使用相同的标志）</li>
</ul>
<p>如果用户发出它指定一个已经存在的接口的名称并且他是接口的所有者，就会发生这种事，因为内核允许<strong>TUNSETIFF</strong> ioctl()成功。在这种情况下，不需要创建新的接口，所以普通用户可以成功执行操作。</p>
<p>接下来将尝试解释当调用ioctl(TUNSETIFF)时发生什么，以及内核如何区分新接口的分配请求和连接到现有接口的请求：</p>
<ul>
<li>如果指定了不存在或不存在的接口名称，则表示用户正在请求分配新的接口。内核因此创建一个使用给定名称的接口（或者如果给出空名称，则选择下一个可用名称）。这只适用于由root完成的工作。</li>
<li>如果指定了现有接口的名称，则表示用户想要连接到以前分配的接口。这可以由普通用户完成，前提是：用户对克隆设备具有适当的权限，并且是接口的所有者（在创建时设置），并且指定模式（tun或tap）与创建时设置的模式相匹配时间。</li>
</ul>
<p>您可以看看在内核源文件drivers/net/tun.c中实现上述步骤的代码;重要的函数是<strong>tun_attach()</strong>，<strong>tun_net_init()</strong>，<strong>tun_set_iff()</strong>，*<em>tun_chr_ioctl()</em>；这最后一个函数还实现了各种可用的ioctl()，包括TUNSETIFF，TUNSETPERSIST，TUNSETOWNER，TUNSETGROUP等。</p>
<p>在任何情况下，都不允许非root用户配置接口（即分配一个IP地址并启动它），但在任何常规接口上也是如此。如果非root用户需要执行某些需要root权限的操作，则可以使用通常的方法（suid二进制包装，sudo等）。</p>
<p>这是一个可能的使用场景（我一直在使用）：</p>
<ul>
<li>虚拟接口被创建，持久化，分配给一个用户，并由root配置（例如，在启动时通过initscripts，使用tunctl或等价物）</li>
<li>然后，普通用户可以根据自己的虚拟接口随意连接和分离。</li>
<li>虚拟接口被root破坏，例如在关机时运行的脚本，可能使用tunctl -d或等价的</li>
</ul>
<h1 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h1><p>经过这么漫长但必要的介绍，是时候尝试使用它了。 所以，由于这是一个普通的接口，我们可以像使用另一个常规接口一样使用它。 对于我们的目的，tun和tap接口没有区别; 创建或附加到它的程序，必须知道它的类型，并相应地期望或写入数据。 我们创建一个持久接口并为其分配一个IP地址：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"># openvpn --mktun --dev tun2</span><br><span class="line">Fri Mar 26 10:29:29 2010 TUN/TAP device tun2 opened</span><br><span class="line">Fri Mar 26 10:29:29 2010 Persist state set to: ON</span><br><span class="line"># ip link set tun2 up</span><br><span class="line"># ip addr add 10.0.0.1/24 dev tun2</span><br></pre></td></tr></table></figure></p>
<p>让启动一个网络分析仪，看看流量：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"># tshark -i tun2</span><br><span class="line">Running as user &quot;root&quot; and group &quot;root&quot;. This could be dangerous.</span><br><span class="line">Capturing on tun2</span><br><span class="line"></span><br><span class="line"># 在另一个控制台</span><br><span class="line"># ping 10.0.0.1</span><br><span class="line">PING 10.0.0.1 (10.0.0.1) 56(84) bytes of data.</span><br><span class="line">64 bytes from 10.0.0.1: icmp_seq=1 ttl=64 time=0.115 ms</span><br><span class="line">64 bytes from 10.0.0.1: icmp_seq=2 ttl=64 time=0.105 ms</span><br><span class="line">...</span><br></pre></td></tr></table></figure></p>
<p>看着tshark的输出，我们看到…什么都没有。 没有流量通过接口。 这是正确的：因为我们正在ping接口的IP地址，所以操作系统正确地判定没有数据包需要“在线”发送，并且内核自己正在回应这些ping。 如果你仔细想想，如果你ping另一个接口的IP地址（例如eth0），会发生什么情况：没有数据包会被发送出去。 这听起来很明显，但起初可能是一个混乱的来源（这是对我来说）。</p>
<p>为一个接口分配一个 /24 IP地址将创建一个通过接口的连接路由。修改一下实验，迫使内核实际上从tun接口发出一些东西（<strong>注意： 内核&lt;2.6.36;后面的内核行为有所不同，如注释中所述</strong>）：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"># ping 10.0.0.2</span><br><span class="line">PING 10.0.0.2 (10.0.0.2) 56(84) bytes of data.</span><br><span class="line">From 10.0.0.1 icmp_seq=2 Destination Host Unreachable</span><br><span class="line">From 10.0.0.1 icmp_seq=3 Destination Host Unreachable</span><br><span class="line">...</span><br><span class="line"></span><br><span class="line"># tshark控制台</span><br><span class="line">...</span><br><span class="line">  0.000000     10.0.0.1 -&gt; 10.0.0.2     ICMP Echo (ping) request</span><br><span class="line">  0.999374     10.0.0.1 -&gt; 10.0.0.2     ICMP Echo (ping) request</span><br><span class="line">  1.999055     10.0.0.1 -&gt; 10.0.0.2     ICMP Echo (ping) request</span><br></pre></td></tr></table></figure></p>
<p>现在我们终于看到了一些东西。 内核看到地址不属于本地接口，通过tun2接口存在10.0.0.0/24的路由。 所以它适时发送tun2的数据包。 请注意tun和tap接口之间的不同行为：使用tun接口，内核发送IP数据包（raw，没有其他头文件存在 - 请尝试使用tshark或wireshark进行分析），而使用tap接口作为以太网， 内核会尝试将ARP作为目标IP地址：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"># pinging 10.0.0.2 now, but through tap2 (tap)</span><br><span class="line"># ping 10.0.0.2</span><br><span class="line">PING 10.0.0.2 (10.0.0.2) 56(84) bytes of data.</span><br><span class="line"></span><br><span class="line"># tshark控制台</span><br><span class="line">...</span><br><span class="line">  0.111858 82:03:d4:07:62:b6 -&gt; Broadcast    ARP Who has 10.0.0.2?  Tell 10.0.0.1</span><br><span class="line">  1.111539 82:03:d4:07:62:b6 -&gt; Broadcast    ARP Who has 10.0.0.2?  Tell 10.0.0.1</span><br><span class="line">...</span><br></pre></td></tr></table></figure></p>
<p>此外，通过一个tap接口，流量将由完整的以太网帧组成（也可以使用网络分析仪进行检查）。 请注意，tap接口的MAC地址是在创建接口时由内核自动生成的，但可以使用<strong>SIOCSIFHWADDR</strong> ioctl()进行更改（再次查看<strong>drivers/net/tun.c</strong>，函数<strong>tun_chr_ioctl()</strong>）。 最后，作为以太网接口，MTU被设置为1500：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"># ip link show dev tap2</span><br><span class="line">7: tap2:  mtu 1500 qdisc pfifo_fast state UNKNOWN qlen 500</span><br><span class="line">    link/ether 82:03:d4:07:62:b6 brd ff:ff:ff:ff:ff:ff</span><br></pre></td></tr></table></figure></p>
<p>当然，到目前为止，程序没有附加到接口，所有这些传出的数据包都丢失了。 所以让我们先行一步，写一个简单的程序，连接到接口并读取内核发出的数据包。</p>
<h1 id="一个简单的程序"><a href="#一个简单的程序" class="headerlink" title="一个简单的程序"></a>一个简单的程序</h1><p>我们将编写一个附加到tun接口的程序，并读取内核发送到该接口的数据包。 请记住，如果接口是持久性的，则可以以普通用户身份运行该程序，前提是您拥有克隆设备<strong>/dev/net/tun</strong>所需的权限、是该接口的所有者、并选择正确的模式（tun或者tap）接口。 该程序实际上是一个框架，或者说是一个框架的开始，因为我们只演示如何从设备读取数据，并且只能解释程序获取数据后可以执行的操作。 我们假设我们之前定义的<strong>tun_alloc()</strong>函数可用于程序。 这里是代码：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line">/* tunclient.c */</span><br><span class="line"></span><br><span class="line">char tun_name[IFNAMSIZ];</span><br><span class="line"></span><br><span class="line">/* 连接到设备 */</span><br><span class="line">strcpy(tun_name, &quot;tun77&quot;);</span><br><span class="line">tun_fd = tun_alloc(tun_name, IFF_TUN | IFF_NO_PI);  /* tun接口 */</span><br><span class="line"></span><br><span class="line">if(tun_fd &lt; 0)&#123;</span><br><span class="line">  perror(&quot;Allocating interface&quot;);</span><br><span class="line">  exit(1);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/* 读取内核发出的数据 */</span><br><span class="line">while(1) &#123;</span><br><span class="line">  /* 请注意，“缓冲区”应至少为接口的MTU大小，例如1500字节 */</span><br><span class="line">  nread = read(tun_fd,buffer,sizeof(buffer));</span><br><span class="line">  if(nread &lt; 0) &#123;</span><br><span class="line">    perror(&quot;Reading from interface&quot;);</span><br><span class="line">    close(tun_fd);</span><br><span class="line">    exit(1);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  /* 处理数据 */</span><br><span class="line">  printf(&quot;Read %d bytes from device %s\n&quot;, nread, tun_name);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">...</span><br></pre></td></tr></table></figure></p>
<p>如果将tun77配置为IP地址为10.0.0.1/24，然后在尝试ping 10.0.0.2（或10.0.0.1以外的10.0.0.0/中的任何地址）时运行上述程序，则可以 从设备读取数据：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"># openvpn --mktun --dev tun77 --user waldner</span><br><span class="line">Fri Mar 26 10:48:12 2010 TUN/TAP device tun77 opened</span><br><span class="line">Fri Mar 26 10:48:12 2010 Persist state set to: ON</span><br><span class="line"># ip link set tun77 up</span><br><span class="line"># ip addr add 10.0.0.1/24 dev tun77</span><br><span class="line"># ping 10.0.0.2</span><br><span class="line">...</span><br><span class="line"></span><br><span class="line"># on another console</span><br><span class="line">$ ./tunclient</span><br><span class="line">Read 84 bytes from device tun77</span><br><span class="line">Read 84 bytes from device tun77</span><br><span class="line">...</span><br></pre></td></tr></table></figure></p>
<p>如果你做数学计算，你会看到这84个字节是从哪里来的：其中20个用于IP头部，8个用于ICMP头部，56个是ICMP回显消息的有效载荷，正如你在运行ping命令时看到的那样：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ ping 10.0.0.2</span><br><span class="line">PING 10.0.0.2 (10.0.0.2) 56(84) bytes of data.</span><br><span class="line">...</span><br></pre></td></tr></table></figure></p>
<p>尝试使用上述程序通过接口发送各种流量类型（也可以尝试使用tap），并验证您正在读取的数据的大小对接口类型是否正确。每个read()返回一个完整的数据包（如果使用tap模式，则返回帧）;同样，如果我们要写，我们将不得不为每个write（）写一个完整的IP数据包（或以太网帧以tap模式）。</p>
<p>现在我们可以用这个数据做什么？那么，我们可以模仿我们正在阅读的交通目标的行为;再次，为了理解简单，再次使用ping示例。我们可以分析接收到的数据包，从IP头，ICMP头和有效负载中提取回复所需的信息，建立一个包含适当的ICMP回应应答消息的IP数据包，并将其发回（即写入与tun/tap设备）。这样ping的发起者实际上会收到一个答案。当然你不限于ping，所以你可以<strong>实现各种网络协议</strong>（读的我热血沸腾）。一般来说，这意味着解析接收到的数据包，并相应地采取行动。如果使用tap，要正确构建回复帧，您可能需要在代码中<strong>实现ARP</strong>。所有这一切正是<a href="http://user-mode-linux.sourceforge.net/" target="_blank" rel="noopener">Linux用户模式</a>所做的：它将在用户空间中运行的修改后的Linux内核连接到主机上存在的分接口，并通过该接口与主机进行通信。当然，作为一个完整的Linux内核，它确实实现了TCP/IP和以太网。较新的虚拟化平台，如<a href="https://libvirt.org/" target="_blank" rel="noopener">libvirt</a>，广泛使用tap接口来与支持它们的客户进行通信，如<a href="https://wiki.qemu.org/Main_Page" target="_blank" rel="noopener">qemu</a>/<a href="https://www.linux-kvm.org/page/Main_Page" target="_blank" rel="noopener">kvm</a>;接口通常具有像<strong>vnet0</strong>，<strong>vnet1</strong>等名称，只有在连接到的guest虚拟机正在运行时存在，它们不会持久化，但是如果在客户端运行<strong>ip link show</strong>和/或<strong>brctl show</strong>，则可以看到它们。<br>以同样的方式，您可以将自己的代码附加到接口并练习网络编程或者以太网和TCP/IP堆栈实现。要开始，你可以看看（你猜对了）<strong>drivers/net/tun.c</strong>，函数<strong>tun_get_user()</strong>和<strong>tun_put_user()</strong>来看看在内核方面tun驱动程序是如何执行的（注意，它几乎不能抓住内核中完整网络数据包管理的表面，这非常复杂）。</p>
<h1 id="Tunnels"><a href="#Tunnels" class="headerlink" title="Tunnels"></a>Tunnels</h1><p>但是还有一件事我们可以用tun/tap接口来做。我们可以创建隧道tunnels。我们不需要重新实现TCP/IP;相反，我们可以编写一个程序，将原始数据来回传递给运行相同程序的远程主机，这种方式以镜面方式执行相同的操作。假设我们上面的程序除了连接到tun/tap接口之外，还建立到远程主机的网络连接，其中一个类似的程序（连接到本地tun/tap接口）也以服务器模式运行。 （实际上这两个程序是一样的，谁是服务器，谁是客户端是由命令行开关决定的）。一旦这两个程序正在运行，流量就可以向两个方向流动，因为代码的主体将在两个站点都做同样的事情。这里的网络连接是使用TCP实现的，但是也可以使用任何其他的意思（即UDP，甚至ICMP！）。你可以在这里下载完整的程序源代码：<a href="http://backreference.org/wp-content/uploads/2010/03/simpletun.tar.bz2" target="_blank" rel="noopener">simpletun</a>。<br>这里是程序的主循环，其中执行在tun/tap接口和网络隧道之间来回移动数据的实际工作。为了清楚起见，调试语句已被删除（您可以在源代码tarball中找到完整版本）。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line">  /* net_fd是网络文件套接字 (to the peer),</span><br><span class="line">   * tap_fd是连接到tun/tap接口的描述符 */</span><br><span class="line"></span><br><span class="line">  /* 使用select()处理两个描述符 */</span><br><span class="line">  maxfd = (tap_fd &gt; net_fd)?tap_fd:net_fd;</span><br><span class="line"></span><br><span class="line">  while(1) &#123;</span><br><span class="line">    int ret;</span><br><span class="line">    fd_set rd_set;</span><br><span class="line"></span><br><span class="line">    FD_ZERO(&amp;rd_set);</span><br><span class="line">    FD_SET(tap_fd, &amp;rd_set); FD_SET(net_fd, &amp;rd_set);</span><br><span class="line"></span><br><span class="line">    ret = select(maxfd + 1, &amp;rd_set, NULL, NULL, NULL);</span><br><span class="line"></span><br><span class="line">    if (ret &lt; 0 &amp;&amp; errno == EINTR) &#123;</span><br><span class="line">      continue;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    if (ret &lt; 0) &#123;</span><br><span class="line">      perror(&quot;select()&quot;);</span><br><span class="line">      exit(1);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    if(FD_ISSET(tap_fd, &amp;rd_set)) &#123;</span><br><span class="line">      /* 来自tun/tap的数据：只需读取并写入网络即可 */</span><br><span class="line"></span><br><span class="line">      nread = cread(tap_fd, buffer, BUFSIZE);</span><br><span class="line"></span><br><span class="line">      /* write length + packet */</span><br><span class="line">      plength = htons(nread);</span><br><span class="line">      nwrite = cwrite(net_fd, (char *)&amp;plength, sizeof(plength));</span><br><span class="line">      nwrite = cwrite(net_fd, buffer, nread);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    if(FD_ISSET(net_fd, &amp;rd_set)) &#123;</span><br><span class="line">      /* 来自网络的数据：读取它，并将其写入tun/tap接口。</span><br><span class="line">       * 我们需要先读取长度，然后读取数据包 */</span><br><span class="line"></span><br><span class="line">      /* 读取长度 */</span><br><span class="line">      nread = read_n(net_fd, (char *)&amp;plength, sizeof(plength));</span><br><span class="line"></span><br><span class="line">      /* 读取数据包 */</span><br><span class="line">      nread = read_n(net_fd, buffer, ntohs(plength));</span><br><span class="line"></span><br><span class="line">      /* 现在buffer[]包含一个完整的数据包或帧，将其写入tun/tap接口 */</span><br><span class="line">      nwrite = cwrite(tap_fd, buffer, nread);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">...</span><br></pre></td></tr></table></figure></p>
<p>（有关<strong>read_n()</strong>和<strong>cwrite()</strong>函数的详细信息，请参考源代码;他们所做的事情应该是显而易见的，上面的代码在select()方面不是100％正确的，并且做出了一些天真的假设 期望read_n（）和cwrite（）不会阻塞。正如我所说的，代码仅用于演示目的）</p>
<p>这是以上代码的主要逻辑：</p>
<ul>
<li>程序使用<strong>select()</strong>来同时控制两个描述符。如果数据是从任何一个描述符进来的，则写入另一个描述符。</li>
<li>由于程序使用TCP，接收者将看到一个单一的数据流，这使得识别数据包边界变得困难。所以当一个数据包或帧被写入网络时，其长度被预先占用（2个字节）到实际数据包。</li>
<li>当数据从tap_fd描述符进入时，一次读取读取一个完整的数据包或帧;因此可以直接将其写入网络，其长度已预先确定。由于长度号码是一个短整型，因此长于一个字节，以“原始”二进制格式写入，所以使用<strong>ntohs()/htons()</strong>在具有不同字节顺序的机器之间进行互操作。</li>
<li>当数据从网络进入时，由于前面提到的技巧，我们可以通过读取数据流之前的两个字节的长度来知道下一个数据包将要处理多长时间。当我们读取数据包时，我们把它写到tun / tap接口描述符中，内核接收它作为“来自线路”。</li>
</ul>
<p>那么你可以用这样的程序做什么？ 那么，你可以创建一个隧道！ 首先，在隧道两端的主机上创建并配置必要的tun / tap接口，包括分配一个IP地址。 对于这个例子，我将假定两个tun接口：本地计算机上的tun11，192.168.0.1/24，远程计算机上的tun3，192.168.0.2/24。 <strong>simpletun</strong>默认连接使用TCP端口55555的主机（您可以使用-p命令行开关更改该端口）。 远程主机将在服务器模式下运行simpletun，并且本地主机将以客户端模式运行。 所以有了下面的例子（远程服务器在10.2.3.4）：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">[remote]# openvpn --mktun --dev tun3 --user waldner</span><br><span class="line">Fri Mar 26 11:11:41 2010 TUN/TAP device tun3 opened</span><br><span class="line">Fri Mar 26 11:11:41 2010 Persist state set to: ON</span><br><span class="line">[remote]# ip link set tun3 up</span><br><span class="line">[remote]# ip addr add 192.168.0.2/24 dev tun3</span><br><span class="line"></span><br><span class="line">[remote]$ ./simpletun -i tun3 -s</span><br><span class="line"># 服务器块等待客户端连接</span><br><span class="line"></span><br><span class="line">[local]# openvpn --mktun --dev tun11 --user waldner</span><br><span class="line">Fri Mar 26 11:17:37 2010 TUN/TAP device tun11 opened</span><br><span class="line">Fri Mar 26 11:17:37 2010 Persist state set to: ON</span><br><span class="line">[local]# ip link set tun11 up</span><br><span class="line">[local]# ip addr add 192.168.0.1/24 dev tun11</span><br><span class="line"></span><br><span class="line">[local]$ ./simpletun -i tun11 -c 10.2.3.4</span><br><span class="line"># 无状况，用户现在已连接</span><br><span class="line">[local]$ ping 192.168.0.2</span><br><span class="line">PING 192.168.0.2 (192.168.0.2) 56(84) bytes of data.</span><br><span class="line">64 bytes from 192.168.0.2: icmp_seq=1 ttl=241 time=42.5 ms</span><br><span class="line">64 bytes from 192.168.0.2: icmp_seq=2 ttl=241 time=41.3 ms</span><br><span class="line">64 bytes from 192.168.0.2: icmp_seq=3 ttl=241 time=41.4 ms</span><br><span class="line">64 bytes from 192.168.0.2: icmp_seq=4 ttl=241 time=41.0 ms</span><br><span class="line"></span><br><span class="line">--- 192.168.0.2 ping statistics ---</span><br><span class="line">4 packets transmitted, 4 received, 0% packet loss, time 2999ms</span><br><span class="line">rtt min/avg/max/mdev = 41.047/41.599/42.588/0.621 ms</span><br><span class="line"></span><br><span class="line"># 尝试刺激的事情</span><br><span class="line">[local]$ ssh waldner@192.168.0.2</span><br><span class="line">waldner@192.168.0.2&apos;s password:</span><br><span class="line">Linux remote 2.6.22-14-xen #1 SMP Fri Feb 29 16:20:01 GMT 2008 x86_64</span><br><span class="line"></span><br><span class="line">Welcome to remote!</span><br><span class="line"></span><br><span class="line">[remote]$</span><br></pre></td></tr></table></figure></p>
<p>当建立如上所述的隧道时，从外部可以看到的只是两个同等简单隧道之间的连接（在这种情况下为TCP）。上面例子中的“真实”数据（即高层应用程序ping或ssh交换的数据）绝不会直接暴露在线路上（尽管它以明文形式发送，见下文）。如果在运行simpletun的主机上启用IP转发，并在其他主机上创建必要的路由，则可以通过隧道到达远程网络。</p>
<p>另外请注意，如果所涉及的虚拟接口是tap类型的，则可以透明地桥接两个地理上距离较远的以太网LAN，以便设备认为它们全部在相同的第2层网络上。为此，需要在网关（即运行simpletun的主机或使用tap接口的另一个隧道软件），本地LAN接口和虚拟分接接口上进行桥接。这样，从局域网接收到的帧也被发送到tap接口（由于网桥），隧道应用程序读取它们并将它们发送给远程对等体;在那里，另一个桥将确保如此接收的帧被转发到远程LAN。同样的事情会发生在相反的方向。由于我们在两个LAN之间传递以太网帧，因此两个LAN有效地桥接在一起。这意味着您可以在伦敦（例如）有10台机器，在柏林有50台机器，您可以使用192.168.1.0/24子网中的地址（或任何您想要的子网地址）创建60台计算机的以太网网络，只要它可以容纳至少60个主机地址）。但是，如果你想设置类似的东西，不要使用simpletun！</p>
<h1 id="Extensions-and-improvements"><a href="#Extensions-and-improvements" class="headerlink" title="Extensions and improvements"></a>Extensions and improvements</h1><p>simpletun非常简单和简单，可以通过多种方式扩展。首先，可以添加连接到对等方的新方法。例如，可以实现UDP连接，或者如果你勇敢的话，也可以通过ICMP（也可以通过IPv6）。其次，数据通过网络连接以明文形式传递。但是，当数据在程序的缓冲区中时，它可能在被传输之前以某种方式被改变，例如它可以被加密（并且在另一端被类似地解密）。</p>
<p>但是，为了本教程的目的，程序的限制版本应该已经给你一个如何使用tun/tap的隧道工作的想法。虽然simpletun是一个简单的演示，但许多流行的使用tun/tap接口的程序也是如此，例如OpenVPN，vtun或Openssh的VPN特性。</p>
<p>最后，值得注意的是，如果隧道连接是通过TCP连接的，那么我们可能会遇到所谓的“tcp over tcp”的情况。有关更多信息，请参阅“为什么tcp over tcp是一个坏主意”。请注意，OpenVPN之类的应用程序默认情况下使用UDP，因此使用TCP以降低性能而闻名（尽管在某些情况下它是唯一的选择）。</p>
<p>善于交际，分享！</p>

          
        
      
    </div>

    

    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://renzheng0403.github.io/2017/11/25/被嫌弃的松子的一生/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="renzheng">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="renz">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2017/11/25/被嫌弃的松子的一生/" itemprop="url">
                  被嫌弃的松子的一生
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">

            
            
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              

              
                
              

              <time title="创建时间：2017-11-25 23:27:00" itemprop="dateCreated datePublished" datetime="2017-11-25T23:27:00+08:00">2017-11-25</time>
            

            
              

              
                
                <span class="post-meta-divider">|</span>
                

                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                
                  <span class="post-meta-item-text">更新于</span>
                
                <time title="修改时间：2018-05-19 09:46:25" itemprop="dateModified" datetime="2018-05-19T09:46:25+08:00">2018-05-19</time>
              
            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/后感/" itemprop="url" rel="index"><span itemprop="name">后感</span></a></span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>从松子的角度来看，被嫌弃的一生其实是追寻的一生。<br>看这个电影，我们可能会像一个看客一样思考，假如松子怎么怎么样。要知道，任何时候我们谈论，假如松子在某个人生的节点如果做出某个在你看来可能更合理的选择都是不客观的。她的一生每一个选择，背后都透露出她的人生态度，这份态度坚决，清晰。<br>这个剧的编剧大概是个太宰治的铁粉，不仅剧中多次出现了相关因素，例如松子被开除后跟随的那个专职作家，自命太宰治的转身;例如杀了合伙人之后选择了结生命的地点。最重要的大概就是该剧与《人间失格》的对比。<br>两部作品构建的根基都是相同的，甚至可能都不是构建，就是赤裸裸的现实。主人公的一生都活在渴望爱却又缺失爱的境地，用刻意扭曲搞怪的面容企图逗乐他人，见证了人性的丑恶，经历的孤独的痛苦，最后在凄惨的年月中年迈死去。不知是否是刻意为之，松子却选择了与叶藏看似不同的选择。</p>
<blockquote>
<p>胆小鬼连幸福都会害怕，碰到棉花都会受伤，有时还会被幸福所伤</p>
</blockquote>
<p>这就是叶藏表现出来的外在性质，但是松子却是一个爱的热烈而坚定的女人。对于太宰治转身的作家男友的爱，对于自杀未遂遇到的理发师的坚守，对于阿龙的生死与共。可是这些在有些人谈论爱情时刻意强调的必备品质并没有为松子带来多少命运的青睐。你会发现撇开人生的意义来单独谈论爱情是没有意义的。纯粹的爱情活在春秋时期，活在希腊史诗中，活在人类文明早期的探索，稍有认知却又认知不全。<br>老实说我对于文学和哲学并没有什么像样的系统学习，只是在某个时期出于本能为了解决自己的性格问题而阅读了一些书，这也是以荒废了理科课程的学习为代价。所以你可以看到，我写的文章都是难登大雅之堂的唠磕。<br>我们在一生之中也会遇到松子的难题，我们都采取了聪明的做法，所以我们看似过得幸福，但是人生也变得没有意义。举身边安稳度日的长辈的例子，相比于那些晚年过得没有他们幸福的长辈来说，他们总是<strong>仿佛</strong>脸上有光。可是他们依然没有得到成长，这就好像做课题研究一样，研究是一件逆熵的过程，总要付出一些代价例如思考、汗水、时间等等，他们避开了这些麻烦，没有接下课题研究的任务，自然也就不会有一个认知的经历过程。可是松子啊，从头到尾都在接受这类课题研究，而且从小到老，随着研究的深入，认知程度也越来越高。如果说人生真的只是一个试炼的话，那么无论是松子还是叶藏，她们都是我们中的佼佼者。<br>写到这里，我也总算对于如何讲述这个感想有了思路，以人生的课题来讲述或许是最符合我的思路，也是我最能把事情将清楚的方式了。</p>
<p>我们先看松子小时候接受的课题吧。要解释这个问题其实也不难，专业术语还真忘了，貌似叫什么情感反馈缺失。也就是说小松子的父母因为太过关心患病的妹妹，忽略了松子的情感需求，就像嗷嗷待哺的雏鸟，长大了嘴却没有被喂食。小松子对于爱的需求，对于焦点的获得，体现在做鬼脸上，这点如出一辙的出现在《人间失格》里。在这个课题上，小松子的处理已经超过很多人了。我妈妈可以举出处理不当的两种反例，这要算我妈最早提出的一个假设。我妈发现一个奇怪的现象，就是有三到四个孩子的家庭里，假如前两个是女孩，那么二女儿的性格通常都会有些怪异。这个例子在我小时候经常生病去的那家医疗室的医生家里很好的体现出来。医疗室是医生夫妇打理，家就在二楼。大女儿又漂亮学习又好，二女儿在学校里打架惹事，穿的也没有医生家里的大小姐，小儿子貌似也挺憨，我那个时候可能只注意大女儿了，年龄比我大不了多少，又很漂亮。我妈的解释是这样的家庭结构，大女儿肯定不会受到忽视，小儿子就更不会了，二女儿可能管教就少了。她还举了我姑家的例子，不过好在我姑对孩子真的是一视同仁，尽管如此二女儿还是有点点怪异。最后我妈又举了自己的例子，我才意识到原来是深有体会。我妈在怀我的时候的那个爆炸头照片现在还很前卫。松子呢，同样的受到忽视，但是没有打架斗殴自暴自弃，也没有沉默寡言自卑自弱，而是学会了鬼脸斗父亲笑，可以说很积极了，又有多少家小孩可以做到这点呢。而且松子通过这招，稍微的达成了焦点的吸引。</p>
<p>第二个课题出现在松子做中学教师的时候。这个课题是没有成功处理的吧，应该是受小时候的影响太深了。这个课题归结为<strong>对他人的需求</strong>。松子在与人面对面交流的时候很难对人说NO，当阿龙在她面前的时候，当阿龙拿出信任这把武器的时候，松子宁愿推翻”是阿龙偷的“这个结论也要提供给阿龙信任，只有当阿龙走的时候才又从新建立结论。当面对店铺老板坚决要求小偷必须当场道歉的时候，情急之前使用本能——做鬼脸，也没有拒绝见小偷这个要求。不敢拒绝，最终生出妥协，成了牺牲品。这个课题是有些难度的，老实说换作是你也不能在段时间内很好的解决。<br>由于这个课题的因是第一个课题的果，导致松子崩溃，进而也将第一个课题的隐患引爆——嫉妒受到关注与呵护的妹妹。</p>
<p>第三个课题算是<strong>爱情与归宿</strong>，但是爱情占据大半，归宿的意味没有后面有个课题强。这个时期的松子与家人断绝了关系，有了一个自比于太宰治转世的男友，可是啊，我相信无论是太宰治还是他小说的主人公，都不会对女性施暴，他们对于女性的态度应该是谄媚和逗乐居多，要么逃避，绝不会出现施暴这一回，这点编剧是不是真心理解偏了，我觉得如果把施暴换成对女性的隐形勾引会更符合太宰治化身这一形象。而且这里的施暴和后面阿龙的施暴明显重合。如果参考《维庸之妻》设计这段情节会更符合。但是无论怎样，这个专职作家都不是一个好的归宿，至于为什么会对这样的人产生爱情，还有爱情究竟是真的还是只是一种表象，对不起，不知道。事实就是松子爱的坚定，爱的不可理喻，爱的遍体鳞伤。<br>在这个课题上，每个人都有每个人的见解，我也和你们一样认为如果施暴，为什么还要在一起，是受虐习惯了吗？会选择离开，但是松子在这个课题上可能还真的做的更好一点。她认定了那就是爱情，事实证明这点她没有错，不会象我们一样因为某些客观因素选择放弃，其实就是放弃爱情。作家自杀后，她也就失去了爱情。爱情的恨与别，折磨与不舍，松子在这个课题里都提会了。</p>
<p>第四个课题延续了第二个课题，即<strong>对他人说NO</strong>的能力。在这个课题里面，松子绝对是选择了一个任性而三观级正的做法，让我们得以看见一个人生逐渐成熟的松子。<br>松子与人合伙做生意，但是合伙人毁约并私吞了松子的心血，在合伙人的欺凌下，松子内心毫无波澜（可能说错了，是很气愤），我们可以看到松子与合伙人直接的心理对峙外加身体反抗。我记得电影里在之前好像铺垫说是作家死了万念俱灰，做这样一个铺垫我不能认同，这是不切和生活的小说的写法，但既然是太宰治流，那么绝对离不开心理的变革。<br>松子在整体上是一个面对困难积极寻找解决办法的人，第一个课题里就讲到她在面对情感反馈缺失就解决的很好，那么在后来她应该会从第二个课题的处理失败中找到正确的处理办法——说NO。而且她说的很彻底，将合伙人杀了。<br>这个课题我不知道你们怎么看，但是我觉得很爽，这是一个已经成熟的人了，如果是这时候的松子来处理第二个课题，那么就不会出现这么多的事情了。人无论怎么犯错，都不过是一个经历与否的问题，所以不要说松子应该怎样做，她做不到的你绝对做不到，因为她代表的是小说家抽象出来的假设，是一种贴近真实的理想状态。</p>
<p>第五个课题就是彻底的<strong>归宿感</strong>了，也是让人忍不住泪目的地方。自杀未遂的松子遇见的理发师就代表了这样一种状态，他其貌不扬，有着中年普通人发福的面孔，做着安稳的职业过着安稳的一生，脾气温柔对人友善，对于经历过这么多的松子来说极具诱惑力。也就是在这个港湾里松子体会到了生活得快乐，我记得这一段镜头特别的祥和，松子也浑身散发圣母的光辉。<br>这是我们普通人认为最明智的选择吧，走到如今这一步的松子也很想就这样生活，所以被警方抓到坐牢，才会眼睛里充满积极的光，对未来的生活充满渴望。在她的想象里，出狱后他就可以与理发师过上这种生活了。可是这种生活得事实是怎样的呢？如果这种生活真的如此理想，为什么文学作品里总是描写不同于此的情况。一种猜想是，这种现实里的生活只是一种妥协。我们对命运低头迷失在了生活得柴米油盐之中，迷失了经由课题感悟人生的可能。这种妥协事实上也是脆弱的，它没有爱情那种强有力的看不见的联系，顶多有某种声称具有法律效率的文件来作为保证。不知道是人类社会的进化还是仅仅作为社会的一种临时状态，说不定我们最终还会重回古时候那种纯粹爱情的时代。<br>挽回正题，出狱的松子怀着怎样的期待不知你能否体会一下，理发店越来越近，走到门口却发现了新的女主人和孩子，松子就这么在门口说了一句早已准备好的台词“我回来了”，离开了，屋内的人谁也没有注意到外面曾有过一个自由的灵魂。<br>你看，即使是松子也和你我一样，败给了归宿感，我们都不愿意再漂泊了。然而这种虚假的归宿感由于其本身的脆弱属性，将松子最后一点希望破灭。</p>
<p>第六个是真正的关于<strong>爱情</strong>的课题了，在这个课题里，你可以也印证了前一个课题 归属感的破灭。我记得在第三个课题里，我没有很好将其归属与<strong>爱情</strong>还是<strong>归宿</strong>，写道这里我自己忽然明白了，因为没有放弃归宿，所以二者兼而有之。但是这里就分得很明确了，最终选择抛弃归宿的松子对于爱情变得更加彻底而疯狂，好像这已经是她最后的精神稻草了。<br>阿龙，这个在第一个课题里将她陷入困境的人，向她坦白了爱意，松子悲愤，只说了句讨厌雨天。只怕是阿龙将从前的事如过山车勾起。<br>回味一下对话：<br><code>你有那么恨我吗？</code><br><code>正相反。</code><br>这样课题涉及的往事不知道该怎么说，如果你想了解什么叫“我只会给松子带来伤害”这段阿龙的内心独白，就一定要看一遍《人间失格》才会懂，大概就是爱到深处才会远离，但是日本人会将这一感情的绝望升华至人生的绝望，才会知道阿龙，这个两度带给松子灾祸的根源，却也因对松子的爱生活在痛苦之中，也算是阿龙的课题吧。阿龙的课题——爱、自我否定。而阿龙在自己的课题——自我否定的错误处理，将松子彻底的推向深渊。<br>到了这一步，阿龙错误的认为自己带给松子的只有痛苦，离开了松子。而松子在对阿龙的期盼落空后，也封闭了自己。<br>另外两个课题分别是友情和偶像，也都以处理失败告终，暂时不想写了，有空再说吧。</p>

          
        
      
    </div>

    

    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://renzheng0403.github.io/2017/11/17/关乎信仰，关乎经历/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="renzheng">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="renz">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2017/11/17/关乎信仰，关乎经历/" itemprop="url">
                  可怕的信仰
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">

            
            
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              

              
                
              

              <time title="创建时间：2017-11-17 23:57:00" itemprop="dateCreated datePublished" datetime="2017-11-17T23:57:00+08:00">2017-11-17</time>
            

            
              

              
                
                <span class="post-meta-divider">|</span>
                

                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                
                  <span class="post-meta-item-text">更新于</span>
                
                <time title="修改时间：2018-05-19 10:03:15" itemprop="dateModified" datetime="2018-05-19T10:03:15+08:00">2018-05-19</time>
              
            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/后感/" itemprop="url" rel="index"><span itemprop="name">后感</span></a></span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>看完《血战钢锯岭》，不得不说还真被Doss的天真无邪给洗了一下我略肮脏的大脑，再加上改编自真人真事，更加让人佩服了。<br>我是相信真有如此信仰坚定之人，虽然不是刻意为之，但是表现确实异于常人。他们好像不懂人情事故，不肯变通，于是我心里不免暗叹一声，涉世未深，涉世未深啊。其实啊，他们究竟经历了哪些生命中不能承受的痛苦，谁也不知道。每次遇到这类人，他们的天真都像一盏发亮的光环，吸引我去观察。<br>我首先揣测，唔，这个家伙，性情乖张，不食人间烟火，肯定是从小生活在安乐乡，偶然性的生活在阳关下，无死角。不对，也许是从小就经历太多已经看淡人生了，你的这点小99在他眼里不算什么。你可以妄加评判一个人的性格，却不能说出这个性格背后代表的真正人格，那么评论一个人的性格又有什么意义呢？<br>如果我没有记错的话，《三体》里记录了一个关于乐观人格和悲观人格的对比。我们先从表象来评判性格。a积极进取，坚信人类科技在有限时间内一定能够取得重大进展，从而能够进行宇宙航行，脱离灭绝的危险，那么我们称a为乐观主义者。b呢，他根据现有的事实推断人类的时间已经不够等到科技成熟的那一天，人类摆脱不了灭绝的结局，我们称b为悲观主义者。<br>事实情况相反，a是一个彻底的悲观主义者，他也一样深知人类的弱小，即使科技取得进步，也有可能被更加强大的外力摧毁，他所做的一切，都是想尽最大的努力逃离地球。正是因为对人类的绝对悲观，才最终促使他即使在人类科技真的取得巨大进展的情况下，仍然义无反顾的选择逃离。这是何等的悲观啊！简直可以媲美那些即使我们国家富强了，也一心想要抓紧移民的人，一模一样啊亲。<br>好了，为什么要说这个呢？只是想说，无论他的表现怎样，你都永远无法判断一个人的真正人格。他有可能在他真人格的基础上发展个变化，而这个变化有几层，你自以为认清了一个人表面下的真正性格究竟是他的第几层面具？<br>那么血战钢锯岭呢？撕掉了第一层表面人格！是的，全片仅仅撕掉了第一层人格，我相信Doss的性格解析做的并没有太深入，所以当我看到他宁愿上军事法庭也不愿意拿枪的时候，给我一个突兀的感觉。在这方面，《阿甘正传》做的挺好的，怎么做到的我已经忘了，但是从头看到尾，乃至今后所做抉择都可能会被他影响。可能阿甘的人格剖析的足够彻底，以至于仿佛我们感到自己度过了他的一生。<br>或许Doss的成型并不来源于经历，而是信仰，即宗教。这真的是我所不能理解的了。我挺想成为一个虔诚的信教徒，但是越是参与宗教，越觉得我可能就是那些站在宗教对立面的原型。甚至一度怀疑自己是不是一个不知道自己是撒旦的撒旦（有点绕）。这或许解释了为什么说归属上帝的人都有福，而有些人归属了上帝却并没有福，因为你在基督的概念里并不是人。<br>Doss对于上帝的信仰无比坚定，而上帝也确实多多加福于他。可能是宗教的力量吧。毫无信仰的可怜鬼真的无比羡慕，在我的眼里，即使真的是上帝创造了我们，那么他的目的可能也只是想知道谁创造的他。</p>

          
        
      
    </div>

    

    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://renzheng0403.github.io/2017/09/30/2017-09-30-mod_pmc模块/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="renzheng">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="renz">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2017/09/30/2017-09-30-mod_pmc模块/" itemprop="url">
                  mod_pmc模块
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">

            
            
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              

              
                
              

              <time title="创建时间：2017-09-30 00:00:00" itemprop="dateCreated datePublished" datetime="2017-09-30T00:00:00+08:00">2017-09-30</time>
            

            
              

              
                
                <span class="post-meta-divider">|</span>
                

                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                
                  <span class="post-meta-item-text">更新于</span>
                
                <time title="修改时间：2018-06-24 23:48:14" itemprop="dateModified" datetime="2018-06-24T23:48:14+08:00">2018-06-24</time>
              
            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/PKI/" itemprop="url" rel="index"><span itemprop="name">PKI</span></a></span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="源代码结构（apache模块结构）"><a href="#源代码结构（apache模块结构）" class="headerlink" title="源代码结构（apache模块结构）"></a>源代码结构（apache模块结构）</h1><p>模块定义：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">module</span> AP_MODULE_DECLARE_DATA pmc_module = &#123;</span><br><span class="line">    STANDARD20_MODULE_STUFF,</span><br><span class="line">    pmc_create_dir_conf,      <span class="comment">/* create per-dir    config structures */</span></span><br><span class="line">    pmc_merge_dir_conf,       <span class="comment">/* merge  per-dir    config structures */</span></span><br><span class="line">    pmc_create_server_conf,   <span class="comment">/* create per-server config structures */</span></span><br><span class="line">    pmc_merge_server_conf,    <span class="comment">/* merge  per-server config structures */</span></span><br><span class="line">    pmc_cmds,                 <span class="comment">/* table of config file commands       */</span></span><br><span class="line">    pmc_register_hooks        <span class="comment">/* register hooks                      */</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>注册钩子处理函数：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">pmc_register_hooks</span><span class="params">(<span class="keyword">apr_pool_t</span> *p)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">/* 注册可选函数 */</span></span><br><span class="line">    APR_REGISTER_OPTIONAL_FN(pmc_check_fail);</span><br><span class="line">    APR_REGISTER_OPTIONAL_FN(pmc_query_attrs);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 日志 */</span></span><br><span class="line">    ap_hook_pre_config(pmc_hook_pre_config, <span class="literal">NULL</span>, <span class="literal">NULL</span>, APR_HOOK_MIDDLE);</span><br><span class="line">    <span class="comment">/* 初始化连接上下文 */</span></span><br><span class="line">    ap_hook_pre_connection(pmc_pre_connection, <span class="literal">NULL</span>, <span class="literal">NULL</span>, APR_HOOK_MIDDLE);</span><br><span class="line">    <span class="comment">/* 检查权限 */</span></span><br><span class="line">    ap_hook_access_checker(pm_permission_check, <span class="literal">NULL</span>, <span class="literal">NULL</span>, APR_HOOK_FIRST);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>指令配置：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">const</span> command_rec pmc_cmds[] =</span><br><span class="line">&#123;</span><br><span class="line">    AP_INIT_TAKE1(<span class="string">"PMCEngine"</span>, cmd_pmc_engine, <span class="literal">NULL</span>, RSRC_CONF, <span class="string">"set pmc engine On or Off"</span>),</span><br><span class="line">    AP_INIT_FLAG(<span class="string">"PMCEngineSkip"</span>, cmd_pmc_engine_skip, <span class="literal">NULL</span>, ACCESS_CONF, <span class="string">"set if pmc is skipped"</span>),</span><br><span class="line">    AP_INIT_TAKE1(<span class="string">"PMCCurlTimeOut"</span>, cmd_pmc_curl_timeout, <span class="literal">NULL</span>, RSRC_CONF, <span class="string">"set pmc curl timeout"</span>),</span><br><span class="line">    AP_INIT_TAKE1(<span class="string">"PMCCurlConnectionTimeOut"</span>, cmd_pmc_curl_connection_timeout, <span class="literal">NULL</span>, RSRC_CONF, <span class="string">"set pmc curl connection timeout"</span>),</span><br><span class="line">    AP_INIT_TAKE1(<span class="string">"PMCControlType"</span>, cmd_pmc_control_type, <span class="literal">NULL</span>, RSRC_CONF, <span class="string">"set pmc control type(Connect or Access)"</span>),</span><br><span class="line">    AP_INIT_TAKE23(<span class="string">"PMCServiceProvider"</span>, cmd_pmc_service_provider, <span class="literal">NULL</span>, RSRC_CONF, <span class="string">"set pmc service provider and uri"</span>),</span><br><span class="line">    AP_INIT_TAKE1(<span class="string">"PMCExtendGranularity"</span>, cmd_pmc_granularity_extend, <span class="literal">NULL</span>, RSRC_CONF, <span class="string">"set pmc entend granularity On or Off"</span>),</span><br><span class="line">    AP_INIT_TAKE1(<span class="string">"PMCUrlEncode"</span>, cmd_pmc_urlencode, <span class="literal">NULL</span>, RSRC_CONF, <span class="string">"set pmc urlencode On or Off"</span>),</span><br><span class="line">    AP_INIT_TAKE1(<span class="string">"PMCEncrypt"</span>, cmd_pmc_encrypt, <span class="literal">NULL</span>, RSRC_CONF, <span class="string">"set pmc encrypt  On or Off"</span>),</span><br><span class="line">    AP_INIT_TAKE2(<span class="string">"PMCEncryptAlgorithm"</span>, cmd_pmc_encrypt_algorithm, <span class="literal">NULL</span>, RSRC_CONF, <span class="string">"set pmc encrypt algorithm"</span>),</span><br><span class="line">    AP_INIT_TAKE1(<span class="string">"PMCFieldUrlDecode"</span>, cmd_pmc_field_urldecode, <span class="literal">NULL</span>, RSRC_CONF, <span class="string">"set pmc field urldecode On or Off"</span>),</span><br><span class="line">    AP_INIT_TAKE1(<span class="string">"PMCUriPattern"</span>, cmd_pmc_uri_pattern, <span class="literal">NULL</span>, RSRC_CONF, <span class="string">"set pmc uri pattern"</span>),</span><br><span class="line">    AP_INIT_TAKE1(<span class="string">"PMCUriRegex"</span>, cmd_pmc_uri_regex, <span class="literal">NULL</span>, RSRC_CONF, <span class="string">"set pmc uri regex"</span>),</span><br><span class="line">    AP_INIT_TAKE23(<span class="string">"PMCHeaderFieldMapping"</span>, cmd_pmc_header_field_mapping, <span class="literal">NULL</span>, RSRC_CONF, <span class="string">"set pmc header field mapping"</span>),</span><br><span class="line">    AP_INIT_TAKE2(<span class="string">"PMCUrlFieldMapping"</span>, cmd_pmc_url_field_mapping, <span class="literal">NULL</span>, RSRC_CONF, <span class="string">"set pmc url field mapping"</span>),</span><br><span class="line"></span><br><span class="line">    &#123;<span class="literal">NULL</span>&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>指令用于在配置文件中设定值。</p>
<p>我自己认为apache这套系统在功能<strong>实现</strong>和<strong>控制</strong>两个方面做的很清晰，在钩子处理函数里面，实现的是业务逻辑，使用的人如果想更改其中的某些选项或者方式，那么只需要通过指令做相应的配置就可以了，即控制。我们想一想魔法世界，巫师并不清楚魔法世界的运作原理，但是使用魔杖念出魔咒，就可以发挥神奇的功效。Apache的指令就是我们的魔咒。还可以自己创造<strong>魔咒</strong>，只要在<code>command_rec pmc_cmds[]</code>里配置并编写相应的函数就能完成。</p>
<p>什么是功能<strong>实现</strong>呢？目前我能想到的和这个系统最像的就是集成电路的制备过程，模块和参数控制，硅片在这个流程里被加工成集成电路，而通过改变设定的参数，你可以控制渗透多少元素或者腐蚀到什么程度。但是这个比喻不好，因为了解这个的人不多。现实中也有同样的例子，或许社会学家就有更形象的例子。</p>
<p>数据来到了这个<code>mod_pmc</code>模块，我想将其设置为接入控制，不需要去分析源代码，改动源代码的结构，只需要在专门设置访问控制的配置文件pmc.conf文件里设置：<code>PMCControlType  Access</code>就可以了。那么接下来在名为<code>PMCControlType  Access</code>的黑盒后面发生了什么？</p>
<p>顺藤摸瓜，在指令配置<code>static const command_rec pmc_cmds[]</code>里发现了<code>AP_INIT_TAKE1(&quot;PMCControlType&quot;, cmd_pmc_control_type, NULL, RSRC_CONF, &quot;set pmc control type(Connect or Access)&quot;),</code>，线索很明确了，<code>cmd_pmc_control_type</code>就是我们下一步要去探访的<strong>函数</strong>，此行吉凶未知，万一他什么也不说，只是给出一副冷冰冰的黑脸怎么办。</p>
<p>我们的在同一个文件<strong>mod_pmc.c</strong>里找到了<code>cmd_pmc_control_type</code>老兄，结果却异常顺利，原来设想的”我不知道啊，某某告诉我的，你去他那里看看“这种对话并没有出现。<code>cmd_pmc_control_type</code>老兄一看就是个实在人，告诉了我他的工作：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">const</span> <span class="keyword">char</span> * <span class="title">cmd_pmc_control_type</span><span class="params">(cmd_parms *params, <span class="keyword">void</span> *dummy, <span class="keyword">const</span> <span class="keyword">char</span> *control_type)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    pmc_module_conf *mconf = ap_get_module_config(params-&gt;server-&gt;module_config, &amp;pmc_module);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (strcasecmp(control_type, <span class="string">"Connect"</span>) == <span class="number">0</span>) &#123;</span><br><span class="line">        mconf-&gt;control_type = CT_CONNECT;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (strcasecmp(control_type, <span class="string">"Access"</span>) == <span class="number">0</span>) &#123;</span><br><span class="line">        mconf-&gt;control_type = CT_ACCESS;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> apr_psprintf(params-&gt;pool, <span class="string">"%s is an invalid control type, must be Connect or Access"</span>, control_type);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>诺，你看，<code>control_type</code>的值也就是<code>cmd_pmc_control_type</code>的值自然是<code>Access</code>，由此将设置<code>mconf-&gt;control_type</code>的值为<code>CT_ACCESS</code>，但是老兄隐藏了<code>ap_get_module_config</code>的线索，我使用人肉搜索也没有找到。包括<code>cmd_params *params</code>参数也没有提供来源，这不重要。重要的是，在钩子处理函数<code>pm_permission_check</code>里看到的通过<code>switch (mconf-&gt;control_type)</code>进行判断有了合理的解释，<code>mconf-&gt;control_type</code>果然是设置好的值，但是与我之前的猜测甚远，并不是在另外某个函数里故意设置的，真相只有一个，那就是<code>cmd_pmc_control_type</code>老兄干的！（此刻响起了名侦探柯南破案成功的音乐）</p>
<p>不要高兴太早，我们还只理清了这个模块的指令的其中一个的实现，举这个例子只是想理清这个模块的架构的大致模样：钩子处理函数处理数据的主要流程，指令注册的函数则对某些参数进行改变，接下来的部分的思路就分两块进行了。</p>
<h1 id="钩子处理函数"><a href="#钩子处理函数" class="headerlink" title="钩子处理函数"></a>钩子处理函数</h1><h2 id="pm-permission-check"><a href="#pm-permission-check" class="headerlink" title="pm_permission_check"></a><code>pm_permission_check</code></h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">st=&gt;start: pm_permission_check</span><br><span class="line">e=&gt;end: return DECLINED</span><br><span class="line">mconf=&gt;operation: mconf = ap_get_module_config(server-&gt;module_config, &amp;pmc_module);</span><br><span class="line">dconf=&gt;operation: dconf = ap_get_module_config(r-&gt;per_dir_config, &amp;pmc_module);</span><br><span class="line">ret=&gt;operation: ret</span><br><span class="line">finish_check=&gt;operation: finish_check</span><br><span class="line">curl=&gt;operation: curl_handle = curl_easy_init();</span><br><span class="line">rconf=&gt;operation: rconf = pmc_create_request_conf(r-&gt;pool);</span><br><span class="line">mconf_service_provider=&gt;operation: mconf-&gt;service_provider//检测服务提供者</span><br><span class="line"></span><br><span class="line">mconf_enable=&gt;condition: mconf-&gt;enable</span><br><span class="line">dconf_skip=&gt;condition: dconf-&gt;skip</span><br><span class="line">mconf_service=&gt;condition: uri == NULL</span><br><span class="line">mconf_control_type=&gt;condition: mconf-&gt;control_type == CT_CONNECT</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">st-&gt;mconf-&gt;mconf_enable</span><br><span class="line">mconf_enable(no, bottom)-&gt;dconf</span><br><span class="line">mconf_enable(yes)-&gt;ret</span><br><span class="line">dconf-&gt;dconf_skip</span><br><span class="line">dconf_skip(yes)-&gt;e</span><br><span class="line">dconf_skip(no, bottom)-&gt;mconf_service</span><br><span class="line">mconf_service(yes)-&gt;e</span><br><span class="line">mconf_service(no, bottom)-&gt;curl</span><br><span class="line">curl-&gt;rconf</span><br><span class="line">rconf-&gt;mconf_control_type</span><br><span class="line">mconf_control_type(yes)-&gt;finish_check</span><br><span class="line">mconf_control_type(no, bottom)-&gt;mconf_service_provider</span><br></pre></td></tr></table></figure>
<p>浩浩荡荡画了这么长flowchar，我决定放弃了，开始是画图比读代码容易理解，此刻画图却成了折磨，还是读代码爽啊。</p>
<p>检查服务提供者算是第一道比较重要的关卡，<code>mconf-&gt;service_provider</code>有三种可能的值：</p>
<ul>
<li><p>SP_LOCAL:</p>
<p>check_permission_with_local(r, mconf)</p>
</li>
<li><p>SP_MTSMS:</p>
<p>check_permission_with_mtsms(r, mconf, curl_handler, new_url)</p>
</li>
<li><p>SP_TJJMS:</p>
<p>mconf-&gt;control_type</p>
<ul>
<li><p>CT_CONNECT</p>
<p>check_permission_with_tjjms(r, mconf, curl_handle, new_url)</p>
</li>
<li><p>CT_ACCESS</p>
</li>
</ul>
</li>
</ul>

          
        
      
    </div>

    

    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://renzheng0403.github.io/2017/09/10/2017-09-10-量子与通信/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="renzheng">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="renz">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2017/09/10/2017-09-10-量子与通信/" itemprop="url">
                  量子与通信
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">

            
            
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              

              
                
              

              <time title="创建时间：2017-09-10 20:50:00" itemprop="dateCreated datePublished" datetime="2017-09-10T20:50:00+08:00">2017-09-10</time>
            

            
              

              
                
                <span class="post-meta-divider">|</span>
                

                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                
                  <span class="post-meta-item-text">更新于</span>
                
                <time title="修改时间：2018-06-24 23:32:06" itemprop="dateModified" datetime="2018-06-24T23:32:06+08:00">2018-06-24</time>
              
            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>前言</p>
<blockquote>
<p>昨天抽空看了一下公司里的一份培训资料——《量子计算和量子通信》，突然觉得自己可能确实正处于某项新技术的萌芽状态。比如Internet最开始也不过是实验室里的小范围产物而已，研究者们认为它可能会方便交流，但是当时的人们也许只会想，这东西能有什么用呢？</p>
<p>再早一点，法拉第演示电磁感应的时候不也是遇到了同样的疑问吗？而现如今也有一种技术，它的理论已经被提出，目前还是实验室的产物，会被人问这东西有什么用，我觉得应该就是量子计算了。遗憾的是，天才发明的东西太难理解，将再一次被科技远远甩开。</p>
<p>当年自己《量子物理》当年可耻的挂了，从此开始了<strong>可耻纪元</strong>。高等数学-&gt;复变函数-&gt;量子物理，这些是了解量子计算和量子通信的基本工具，虽然很不情愿，但为了量子计算机，也只能硬着头皮去学了，被时代抛弃真的是很不情愿。<br>下面的内容都是毫无头脑的简单积累，不涉及科学系统学习。</p>
</blockquote>
<h1 id="量子力学基础"><a href="#量子力学基础" class="headerlink" title="量子力学基础"></a>量子力学基础</h1><h2 id="量子态的叠加（干涉）性"><a href="#量子态的叠加（干涉）性" class="headerlink" title="量子态的叠加（干涉）性"></a>量子态的叠加（干涉）性</h2><h2 id="量子纠缠性"><a href="#量子纠缠性" class="headerlink" title="量子纠缠性"></a>量子纠缠性</h2><h2 id="量子不可克隆性定理"><a href="#量子不可克隆性定理" class="headerlink" title="量子不可克隆性定理"></a>量子不可克隆性定理</h2><h2 id="量子不确定性原理"><a href="#量子不确定性原理" class="headerlink" title="量子不确定性原理"></a>量子不确定性原理</h2><h1 id="量子计算"><a href="#量子计算" class="headerlink" title="量子计算"></a>量子计算</h1><h2 id="shor算法"><a href="#shor算法" class="headerlink" title="shor算法"></a>shor算法</h2><h2 id="Grover算法"><a href="#Grover算法" class="headerlink" title="Grover算法"></a>Grover算法</h2><h1 id="量子密钥分发（QKD）"><a href="#量子密钥分发（QKD）" class="headerlink" title="量子密钥分发（QKD）"></a>量子密钥分发（QKD）</h1><h2 id="BB84协议"><a href="#BB84协议" class="headerlink" title="BB84协议"></a>BB84协议</h2><h2 id="E91协议"><a href="#E91协议" class="headerlink" title="E91协议"></a>E91协议</h2><h2 id="附"><a href="#附" class="headerlink" title="附"></a>附</h2><p>Quantum Secret Sharing<br>Quantum Coin Tossing<br>Quantum Bit Commitment<br>Quantum Public-Key Cryptosystem</p>
<h1 id="课外阅读"><a href="#课外阅读" class="headerlink" title="课外阅读"></a>课外阅读</h1><p><a href="http://peterhs.blog.51cto.com/6318839/1104560" target="_blank" rel="noopener">量子计算机编程原理简介 和 机器学习</a></p>
<p><a href="http://open.163.com/special/cuvocw/liangzijishu.html" target="_blank" rel="noopener">中国科学技术大学公开课：来自量子世界的新技术</a></p>
<p><a href="http://blog.csdn.net/column/details/16030.html" target="_blank" rel="noopener">量子力学及量子计算</a></p>
<p><a href="https://zhuanlan.zhihu.com/p/22306837" target="_blank" rel="noopener">从量子力学到量子卫星：如何在量子科学领域谈笑风生|袁岚峰</a></p>
<p><a href="http://www.quantum-comm.com/index.html" target="_blank" rel="noopener">国盾量子</a></p>
<p><a href="http://www.qasky.com/" target="_blank" rel="noopener">问天量子</a></p>

          
        
      
    </div>

    

    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://renzheng0403.github.io/2017/09/09/2017-09-09-SSL-and-TLS-知识点/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="renzheng">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="renz">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2017/09/09/2017-09-09-SSL-and-TLS-知识点/" itemprop="url">
                  SSL and TLS 知识点
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">

            
            
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              

              
                
              

              <time title="创建时间：2017-09-09 00:00:00" itemprop="dateCreated datePublished" datetime="2017-09-09T00:00:00+08:00">2017-09-09</time>
            

            
              

              
                
                <span class="post-meta-divider">|</span>
                

                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                
                  <span class="post-meta-item-text">更新于</span>
                
                <time title="修改时间：2018-06-24 23:18:40" itemprop="dateModified" datetime="2018-06-24T23:18:40+08:00">2018-06-24</time>
              
            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/SSL/" itemprop="url" rel="index"><span itemprop="name">SSL</span></a></span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>TLS四个核心主协议：</p>
<ul>
<li>handshake protocol 握手协议</li>
<li>change cipher spec protocol 密钥规格变更协议</li>
<li>application data protocol 应用数据协议</li>
<li><p>alert protocol 警报协议</p>
</li>
<li><p>record协议：包括对消息的分段、压缩、消息认证和完整性保护、加密</p>
</li>
</ul>
<p>SSL核心功能：握手、密钥交换、相互认证、保密数据传输</p>
<p>SSL握手的三个目的：</p>
<ul>
<li>客户端与服务器就一组保护数据的算法达成一致</li>
<li>确立一组由算法使用的密钥</li>
<li>还可以选择对客户端身份进行认证</li>
</ul>
<p>由于SSL/TLS协议自身特性（数字证书），不能被用于保护多跳端到端通信，只能保护点到点通信。</p>
<p>SSL/TLS协议能够提供的安全目标：</p>
<ul>
<li>身份认证（数字证书）</li>
<li>机密传输（信息加密）</li>
<li>数据完整性（MAC）</li>
<li>重放保护（通过使用隐式序列号防止重放攻击）</li>
</ul>
<h1 id="SSL总体流程"><a href="#SSL总体流程" class="headerlink" title="SSL总体流程"></a>SSL总体流程</h1><p><img src="/images/SSL握手概述.png" alt="SSL握手概述"></p>
<ol>
<li>客户端将其支持的算法列表和一个用作密钥生成算法输入的随机数发送给服务器</li>
<li>服务器选择一个加密算法，并将其和包含服务器公钥的证书发送给客户端，还包括一个用作密钥生成算法输入的随机数</li>
<li>客户端验证服务器证书，并抽取服务器公钥。同时生成一个pre_master_secret随即密码串，然后使用服务器公钥对其进行加密，将加密的信息发送给服务器</li>
<li>客户端和服务器根据pre_master_secret和随机数值独立计算加密密钥和MAC密钥</li>
<li>客户端将所有握手消息MAC值加密后发送给服务器</li>
<li>服务器将所有握手消息MAC值加密后发送给客户端</li>
</ol>
<h1 id="SSL连接"><a href="#SSL连接" class="headerlink" title="SSL连接"></a>SSL连接</h1><p><img src="/images/SSL连接.png" alt="SSL连接"></p>
<ol>
<li>握手消息ClientHello，用于告知服务器客服端所支持的密码套件种类、最高SSL/TLS协议版本以及压缩算法。还包括一个客户端生成的用于密钥产生的随机数，在密钥生成过程中被使用（其它有Session值，第一次握手为0；版本号）</li>
<li>服务器返回的一系列握手消息。首先是ServerHello，包含了服务器选择的加密参数。还包括一个服务器生成的用于密钥产生的随机数，如果是第一次握手，服务器将提供给客户端一个Session值用于恢复使用已经协商好的密钥信息</li>
<li>服务器发送Certificate，该消息是X.509证书序列，证书依序提供，从服务器证书开始，到Certificate authority或者最新的自签名证书结束。同时证书会附带携带与协商的密钥交换算法对应的密钥。客户端除了校验签名信息，还要保证证书链中的所有证书均未被吊销。</li>
<li>ServerHelloDone，表示服务器已发送在此阶段要发送的全部信息。此项告诉客户端本次Certificate后面没有可选信息，不用再等了</li>
<li>ClientKeyExchange客户端验证了服务端证书并并抽取公钥后，使用服务器公钥对生成的被称为pre_master_secret的随机密钥串加密，再通过此消息发送</li>
<li>ChangeCipherSpec告诉服务器，客户端之后的消息都是用商定的加密算法，此消息不属于握手消息，</li>
<li>Finished 发送前一阶段的所有握手消息MAC值，对握手消息校验，这样服务器可以判断使用的加密算法是否是安全商定的，而没有遭到中间人篡改或诱导</li>
<li>ChangeCipherSpec告诉客户端，服务器之后的消息都使用商定的加密算法</li>
<li>Finished</li>
</ol>
<h2 id="ClientHello"><a href="#ClientHello" class="headerlink" title="ClientHello"></a>ClientHello</h2><p>结构体：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">struct &#123;</span><br><span class="line"> ProtocolVersion client_version;</span><br><span class="line"> Random random;</span><br><span class="line"> SessionlD session_id; </span><br><span class="line">  CipherSuite cipher_suites&lt;2..2^16-1&gt;;</span><br><span class="line"> CompressionMethod compression_methods&lt;l..2^8-1&gt;;</span><br><span class="line">&#125; ClientHello;</span><br><span class="line"></span><br><span class="line">struct &#123;</span><br><span class="line"> uint8 major;</span><br><span class="line"> uint8 minor;</span><br><span class="line">&#125; ProtocolVersion;</span><br><span class="line"></span><br><span class="line">struct &#123;</span><br><span class="line"> uint32 gmt_unix_time;</span><br><span class="line"> opaque random_bytes[28];</span><br><span class="line">&#125; Random;</span><br><span class="line"></span><br><span class="line">opaque SessionlD&lt;0..32&gt;;</span><br><span class="line">uint8 CipherSuite[2];</span><br><span class="line">enum &#123;null(0),(255)&#125; CompressionMethod;</span><br></pre></td></tr></table></figure></p>
<p>消息：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line">Handshake Protocol: Client Hello</span><br><span class="line">    Handshake Type: Client Hello (1)</span><br><span class="line">    Version: TLS 1.2 (0x0303)</span><br><span class="line">    Random</span><br><span class="line">        GMT Unix Time: Apr 13, 2053 09:32:30.000000000 �й���׼ʱ��</span><br><span class="line">        Random Bytes: b383297830cf9a3e82ddd7152edff8f6d015fbd697f3a5d8...</span><br><span class="line">    Session ID: d8ae81d62bd18b0cc3f1e7b8774bdd2b1e4755419ab1058e...</span><br><span class="line">    Cipher Suites (14 suites)</span><br><span class="line">        Cipher Suite: TLS_ECDHE_ECDSA_WITH_AES_128_GCM_SHA256 (0xc02b)</span><br><span class="line">        Cipher Suite: TLS_ECDHE_RSA_WITH_AES_128_GCM_SHA256 (0xc02f)</span><br><span class="line">        Cipher Suite: TLS_ECDHE_ECDSA_WITH_AES_256_GCM_SHA384 (0xc02c)</span><br><span class="line">        Cipher Suite: TLS_ECDHE_RSA_WITH_AES_256_GCM_SHA384 (0xc030)</span><br><span class="line">        Cipher Suite: TLS_ECDHE_RSA_WITH_AES_128_CBC_SHA (0xc013)</span><br><span class="line">        Cipher Suite: TLS_ECDHE_RSA_WITH_AES_256_CBC_SHA (0xc014)</span><br><span class="line">        Cipher Suite: TLS_RSA_WITH_AES_128_GCM_SHA256 (0x009c)</span><br><span class="line">        Cipher Suite: TLS_RSA_WITH_AES_256_GCM_SHA384 (0x009d)</span><br><span class="line">        Cipher Suite: TLS_RSA_WITH_AES_128_CBC_SHA (0x002f)</span><br><span class="line">        Cipher Suite: TLS_RSA_WITH_AES_256_CBC_SHA (0x0035)</span><br><span class="line">        Cipher Suite: TLS_RSA_WITH_3DES_EDE_CBC_SHA (0x000a)</span><br><span class="line">    Compression Methods (1 method)</span><br><span class="line">        Compression Method: null (0)</span><br><span class="line">    Extensions Length: 407</span><br><span class="line">    Extension: renegotiation_info</span><br><span class="line">        Renegotiation Info extension</span><br><span class="line">            Renegotiation info extension length: 0</span><br><span class="line">    Extension: server_name</span><br><span class="line">        Server Name Indication extension</span><br><span class="line">            Server Name: www.baidu.com</span><br><span class="line">    Extension: signature_algorithms</span><br><span class="line">        Signature Hash Algorithms (9 algorithms)</span><br><span class="line">            Signature Hash Algorithm: 0x0403</span><br><span class="line">                Signature Hash Algorithm Hash: SHA256 (4)</span><br><span class="line">                Signature Hash Algorithm Signature: ECDSA (3)</span><br><span class="line">            Signature Hash Algorithm: 0x0401</span><br><span class="line">                Signature Hash Algorithm Hash: SHA256 (4)</span><br><span class="line">                Signature Hash Algorithm Signature: RSA (1)</span><br><span class="line">            </span><br><span class="line">    Extension: elliptic_curves</span><br><span class="line">        Elliptic curves (4 curves)</span><br><span class="line">            Elliptic curve: Unknown (0xaaaa)</span><br><span class="line">            Elliptic curve: Unknown (0x001d)</span><br><span class="line">            Elliptic curve: secp256r1 (0x0017)</span><br><span class="line">            Elliptic curve: secp384r1 (0x0018)</span><br></pre></td></tr></table></figure></p>
<p>客户端在新建连接后，希望重新协商或者响应服务器发起的重新协商请求时，发送这条消息。该消息将客户端的功能和首选项传送给服务器，包含以下关键元素：</p>
<ul>
<li>Version 协议版本，包含客户端准备接受的最高SSL版本号</li>
<li>Random 握手时客户端与服务器都会提供随机数，用于身份验证，可以防止重放攻击（<strong>但是为什么</strong>）<ul>
<li>Client time（4byte)产生消息时的时间</li>
<li>Random bytes（28byte）随机生成，确保即使使用同一个pre_master_secret</li>
</ul>
</li>
<li>Session ID客户端用来指示希望重复使用前一次连接是的加密密钥资料</li>
<li>Ciper Suites 密码套件，指定服务器的认证算法、密钥交换算法、批量加密算法和摘要算法（消息完整性）。可参考(ssl握手协议中的CipherSuite)[<a href="http://blog.csdn.net/dog250/article/details/5750992]" target="_blank" rel="noopener">http://blog.csdn.net/dog250/article/details/5750992]</a> ，baidu一篇正好是公司前辈的文章</li>
<li>Compression Methods 客户端可以提交一个或多个支持压缩的方法。默认的压缩方法是null</li>
<li>Extensions 扩展额外数据</li>
</ul>
<h2 id="ServerHello"><a href="#ServerHello" class="headerlink" title="ServerHello"></a>ServerHello</h2><p>将服务器选择的连接参数传回客户端<br>结构与ClientHello类似：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">Handshake Protocol: Server Hello</span><br><span class="line">    Version: TLS 1.2 (0x0303)</span><br><span class="line">    Random</span><br><span class="line">        GMT Unix Time: Sep  9, 2017 14:38:09.000000000 �й���׼ʱ��</span><br><span class="line">        Random Bytes: d3fe2fbdbbe626fc09b691158652d6808239d05b7b9ed0a3...</span><br><span class="line">    Session ID: d8ae81d62bd18b0cc3f1e7b8774bdd2b1e4755419ab1058e...</span><br><span class="line">    Cipher Suite: TLS_ECDHE_RSA_WITH_AES_128_GCM_SHA256 (0xc02f)</span><br><span class="line">    Compression Method: null (0)</span><br><span class="line">    Extension: Application Layer Protocol Negotiation</span><br><span class="line">        ALPN Protocol</span><br><span class="line">            ALPN Next Protocol: http/1.1</span><br></pre></td></tr></table></figure></p>
<p>服务器也提供了一个随机值，用它连同客户端提供的随机值，以及pre_master_secret一起产生密钥资料。</p>
<h2 id="Certificate"><a href="#Certificate" class="headerlink" title="Certificate"></a>Certificate</h2><p>X.509证书序列</p>
<h2 id="ServerHelloDone"><a href="#ServerHelloDone" class="headerlink" title="ServerHelloDone"></a>ServerHelloDone</h2><p>是一条空消息，表明服务器已经发送了在此阶段要发送的全部消息</p>
<h2 id="ClientKeyExchange"><a href="#ClientKeyExchange" class="headerlink" title="ClientKeyExchange"></a>ClientKeyExchange</h2><p>携带客户端为密钥交换提供的所有信息<br>结构体：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">struct &#123;</span><br><span class="line"> select (KeyExchangeAIgorithm) &#123;</span><br><span class="line"> case rsa: EncryptedPreMasterSecret;</span><br><span class="line"> case diffie_hellman: DiffieHellmanClientPublicValue;</span><br><span class="line"> &#125; exchange_keys;</span><br><span class="line">&#125; ClientKeyExchange;</span><br><span class="line">struct &#123;</span><br><span class="line"> ProtocolVersion client_version;</span><br><span class="line"> opaque random[46];</span><br><span class="line">&#125; PreMasterSecret;</span><br><span class="line">struct &#123;</span><br><span class="line"> public-key-encrypted PreMasterSecret pre_master_secret;</span><br><span class="line">&#125; EncryptedPreMasterSecret;</span><br><span class="line">enum &#123; implicit, explicit &#125; PublicValueEncoding;</span><br><span class="line">struct &#123;</span><br><span class="line"> select (PublicValueEncoding) &#123;</span><br><span class="line"> case implicit: struct &#123;&#125;;</span><br><span class="line"> case explicit: opaque DH_Yc&lt;I..2^16-1 &gt;;</span><br><span class="line"> &#125; dh_public;</span><br><span class="line">&#125; DiffieHellmanClientPublicValue;</span><br></pre></td></tr></table></figure></p>
<h2 id="ChangeCipherSpec（不属于握手消息）"><a href="#ChangeCipherSpec（不属于握手消息）" class="headerlink" title="ChangeCipherSpec（不属于握手消息）"></a>ChangeCipherSpec（不属于握手消息）</h2><p>指示发送实现已经切换好的算法和密钥资料，之后发送的消息将使用算法加以保护</p>
<h2 id="Finished"><a href="#Finished" class="headerlink" title="Finished"></a>Finished</h2><p>结构体：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">SSLv3:</span><br><span class="line">struct &#123;</span><br><span class="line"> opaque md5_hash[16];</span><br><span class="line"> opaque sha_hash[20];</span><br><span class="line">&#125;Finished;</span><br><span class="line">TLS:</span><br><span class="line">struct &#123;</span><br><span class="line"> opaque verify_data[12];</span><br><span class="line">&#125; Finished;</span><br></pre></td></tr></table></figure></p>
<p>每一方向另一方发送协商后的主密码与连结起来的握手消息的摘要信息，另一方将其与本地计算得出的摘要对比。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">md5_hash = MD5(master_secret + pad2 + MD5(handshake_messages + Sender + master_secret + pad1) );</span><br></pre></td></tr></table></figure>
<p>第一遍调用MD5的输入：所有握手消息、Sender常量、master_secret、填充字节（pad1为字节0x36重复48次所形成的字符串）</p>
<p>第二遍调用MD5的输入：主密码、填充字节（pad2为字节0x5c重复48次所形成的字符串）、第一遍的输出</p>
<p>Finished另一个有趣的地点在于第二个发送Finished的一方将前一个Finished的消息计算在摘要值之内的可能性，如下图所示：<br><img src="/images/SSL-handshark-Finished.png" alt="Finished"><br>这样当服务器计算握手消息的时候会多计算两个握手消息，必然不会匹配。解决的办法是在处理Finished消息之前再创建一份摘要对象的拷贝。</p>
<h1 id="SSL记录协议"><a href="#SSL记录协议" class="headerlink" title="SSL记录协议"></a>SSL记录协议</h1><p><img src="/images/SSL记录层.png" alt="SSL记录层协议"></p>
<p>SSL记录层协议将数据流分割成片段加密传输</p>
<p>记录头包含三种信息：内容类型、长度、SSL版本</p>
<p>结构体：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">struct &#123;</span><br><span class="line"> ContentType type;</span><br><span class="line"> ProtocolVersion version;</span><br><span class="line"> uint16 length;</span><br><span class="line">&#125; RecordHeader;</span><br><span class="line">enum &#123;</span><br><span class="line"> change_cipher_spec(20), alert(21), handshake(22),</span><br><span class="line"> application_data(23), (255)</span><br><span class="line">&#125; ContentType;</span><br><span class="line">struct &#123;</span><br><span class="line"> uint8 major;</span><br><span class="line"> uint8 minor;</span><br><span class="line">&#125; ProtocolVersion;</span><br></pre></td></tr></table></figure></p>
<h2 id="内容类型"><a href="#内容类型" class="headerlink" title="内容类型"></a>内容类型</h2><p>SSL支持四种内容类型：application_data、alert、handshark、change_cipher_spec</p>
<p>alert用于报告各种类型的错误</p>
<p>handshark用于承载握手信息</p>
<p>change_cipher_spec表示加密及认证的改变，指示使用新的密钥</p>
<h2 id="长度"><a href="#长度" class="headerlink" title="长度"></a>长度</h2><p>让接收方知道要从线路上读取多少字节消息</p>
<h2 id="版本号"><a href="#版本号" class="headerlink" title="版本号"></a>版本号</h2><h1 id="会话恢复"><a href="#会话恢复" class="headerlink" title="会话恢复"></a>会话恢复</h1><p>先看与百度的握手过程：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">459	22.284378	192.168.41.110	115.239.211.112	TLSv1.2	571	Client Hello</span><br><span class="line">461	22.294188	115.239.211.112	192.168.41.110	TLSv1.2	150	Server Hello</span><br><span class="line">462	22.294210	115.239.211.112	192.168.41.110	TLSv1.2	60	Change Cipher Spec</span><br><span class="line">464	22.295709	115.239.211.112	192.168.41.110	TLSv1.2	99	Hello Request, Hello Request</span><br><span class="line">465	22.295942	192.168.41.110	115.239.211.112	TLSv1.2	105	Change Cipher Spec, Hello Request, Hello Request</span><br><span class="line">468	22.299020	192.168.41.110	115.239.211.112	TLSv1.2	82	Application Data</span><br><span class="line">...</span><br></pre></td></tr></table></figure></p>
<p>这里由于ClientHello提供了一个Session，使用了前一次SSL握手协商好的加密密钥信息，因此当客户端接收到ServerHello后就发送ChangeCipherSpec通知服务端后面的消息将使用之前的加密密钥加密</p>
<p>可以发现省略了Certificate，ClientKeyExchange，并不涉及到密钥及加密算法交换等信息，而且此后的消息都是通过加密密钥发送的，如果攻击者冒充服务端，自然无法解开收到的消息，这解释了为什么客户端没有验证服务端身份。</p>
<p>恢复SSL会话流程：<br><img src="/images/SSL-Session.png" alt="SSL-Session"></p>
<h1 id="客户端身份验证"><a href="#客户端身份验证" class="headerlink" title="客户端身份验证"></a>客户端身份验证</h1><p>服务器通过发送CertificateRequest消息请求对客户端进行身份验证，客户端接受后发送自己的Certificate消息，再发送CertificateVerify消息证明自己拥有对应的私钥。</p>
<p>服务器将告诉客户端，我接受哪些证书和签名算法，或者接受哪些证书颁发机构：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">struct &#123;</span><br><span class="line">    ClientCertificateType certificate_types;</span><br><span class="line">    SignatureAndHashAlgorithm supported_signature_algorithms;</span><br><span class="line">    DistinguishedName certificate_authorities;</span><br><span class="line">&#125; CertificateRequest;</span><br><span class="line">enum&#123;</span><br><span class="line"> rsa_sign(1),dss_sign(2),rsa_fixed_dh(3),dss_fixed_dh(4),</span><br><span class="line"> (255)</span><br><span class="line">&#125;ClientCertificateType;</span><br><span class="line">opaque DistinguishedName&lt;l..2^16-1&gt;;</span><br></pre></td></tr></table></figure></p>
<p>客户端将发送一条到这一步为止的所有握手消息的签名，以此证明自己拥有的私钥与之前发送的客户端证书中的公钥匹配：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">struct &#123;</span><br><span class="line">    Signature handshark_message_signature;</span><br><span class="line">&#125; CertificateVerify;</span><br></pre></td></tr></table></figure></p>
<p>若是你对我的私钥与证书中CA机构确认的公钥有怀疑，可以自己进行计算签名值对比（我觉得一定会的）</p>
<h1 id="临时RSA"><a href="#临时RSA" class="headerlink" title="临时RSA"></a>临时RSA</h1><p>ServerKeyExchange（在ServerHelloDone之前）服务器使用该消息传输经过签名的512bit RSA密钥，客户端收到该消息后，验证临时密钥上的服务器签名，并使用其加密pre_master_secret</p>
<h1 id="再握手（Rehandshake）"><a href="#再握手（Rehandshake）" class="headerlink" title="再握手（Rehandshake）"></a>再握手（Rehandshake）</h1><p>建立SSL连接之后再进行一次握手，客户端发送一条ClientHello，如果服务器同意，发送空的HelloRequest握手消息，客户端发送ClientHello作为响应。如果服务器不同意，发送一条no_renegotiation警示。</p>
<h1 id="密钥交换算法的区别"><a href="#密钥交换算法的区别" class="headerlink" title="密钥交换算法的区别"></a>密钥交换算法的区别</h1><p>密钥交换的目的是计算<strong>预主密钥</strong>（premaster secret），这个值是组成<strong>主密钥</strong>（master secret）的来源。</p>
<h2 id="TLS-RSA"><a href="#TLS-RSA" class="headerlink" title="TLS-RSA"></a>TLS-RSA</h2><p>PreMasterSecret由客户端指定，并用RSA公钥加密发送给服务器。</p>
<h2 id="TLS-DH"><a href="#TLS-DH" class="headerlink" title="TLS-DH"></a>TLS-DH</h2><p>双方各自提交一个证书包含DH公开值，服务器端提交证书包含DH公开值。</p>
<h2 id="TLS-DHE"><a href="#TLS-DHE" class="headerlink" title="TLS-DHE"></a>TLS-DHE</h2><p>基于DHE的TLS握手中有ServerKeyExchange消息。DH参数和它的数字签名均被包含在消息中，握手过程中交换参数的认证就是通过数字签名实现，支持的签名算法包括RSA和DSS。</p>
<h2 id="附：Diffie-Hellman密钥交换"><a href="#附：Diffie-Hellman密钥交换" class="headerlink" title="附：Diffie-Hellman密钥交换"></a>附：Diffie-Hellman密钥交换</h2><p>抛开算法的细节（因为我不懂），DH密钥交换需要6个参数：</p>
<ul>
<li>域参数（服务器选取）<ul>
<li>dh_p</li>
<li>dh_g</li>
</ul>
</li>
<li>客户端<ul>
<li>dh_Ys</li>
<li>dh_Yc</li>
</ul>
</li>
<li>服务器<ul>
<li>dh_Ys</li>
<li>dh_Yc</li>
</ul>
</li>
</ul>
<p>协商过程中客户端和服务器相互发送其中一个参数（dh_Ys和dh_Yc）到对端</p>
<p>服务器发送ServerDHparams:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">struct &#123;</span><br><span class="line">    opaque dh_p;</span><br><span class="line">    opaque dh_g;</span><br><span class="line">    opaque dh_Ys;</span><br><span class="line">&#125; ServerDHParams;</span><br></pre></td></tr></table></figure></p>
<p>客户端相应并发送其公开参数（dh_Yc）:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">struct &#123;</span><br><span class="line">    select (PublicValueEncoding) &#123;</span><br><span class="line">        case implicit:</span><br><span class="line">        case explicit:</span><br><span class="line">            opaque dh_Yc;</span><br><span class="line">    &#125; dh_public;</span><br><span class="line">&#125;ClientDiffHellmanPublic;</span><br></pre></td></tr></table></figure></p>
<h1 id="密钥生成"><a href="#密钥生成" class="headerlink" title="密钥生成"></a>密钥生成</h1><p>Pseudo-random Function（PRF，伪随机函数）：秘密值扩展、密钥生成</p>
<p>工作原理如图<br><img src="/images/PRF.png" alt=""><br>PRF基于两个hash函数：MD5和SHA-1；</p>
<p>有三个输入：</p>
<ul>
<li>Secret，例如PreMasterSecret，在使用时被分为长度相同的两半：S1和S2，跟别作为P_MD5和P_SHA-1的输入。</li>
<li>Label标志服</li>
<li>Seed种子值（客户端随机数+服务器随机数）</li>
</ul>
<p>SSL/TLS协议密钥的生成过程：<br><img src="/images/SSL-key.png" alt=""></p>

          
        
      
    </div>

    

    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://renzheng0403.github.io/2017/09/07/2017-09-07-markdown-flow/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="renzheng">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="renz">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2017/09/07/2017-09-07-markdown-flow/" itemprop="url">
                  markdown flow
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">

            
            
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              

              
                
              

              <time title="创建时间：2017-09-07 00:00:00" itemprop="dateCreated datePublished" datetime="2017-09-07T00:00:00+08:00">2017-09-07</time>
            

            
              

              
                
                <span class="post-meta-divider">|</span>
                

                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                
                  <span class="post-meta-item-text">更新于</span>
                
                <time title="修改时间：2018-06-24 23:25:08" itemprop="dateModified" datetime="2018-06-24T23:25:08+08:00">2018-06-24</time>
              
            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/前端/" itemprop="url" rel="index"><span itemprop="name">前端</span></a></span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="flowchart"><a href="#flowchart" class="headerlink" title="flowchart"></a>flowchart</h1><p>流程图语法分为两部分：</p>
<ul>
<li>定义流程图元素</li>
<li>定义流程图的执行走向（用来连接流程图元素）</li>
</ul>
<h2 id="定义元素"><a href="#定义元素" class="headerlink" title="定义元素"></a>定义元素</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tag=&gt;type: content</span><br></pre></td></tr></table></figure>
<h3 id="说明"><a href="#说明" class="headerlink" title="说明"></a>说明</h3><ul>
<li><strong>tag</strong>流程图的标签，用来在定义执行走向的时候指定下一步到达何处，可理解为<strong>名字</strong></li>
<li><strong>type</strong>确定标签类型，表示这个标签的种类是开始结束，输入输出还是判断等</li>
<li><strong>content</strong>流程图文本框内的描述内容</li>
</ul>
<h3 id="标签类型"><a href="#标签类型" class="headerlink" title="标签类型"></a>标签类型</h3><ul>
<li><code>start</code>：开始<code>st=&gt;start: 开始</code></li>
<li><code>end</code>：结束<code>e=&gt;end: 结束</code></li>
<li><code>operation</code>：操作、步骤、执行说明<code>op1=&gt;operation: come to eat</code></li>
<li><code>subroutine</code>：子步骤<code>sb1=&gt;subroutine: go back</code></li>
<li><code>condition</code>：条件选择<code>cond=&gt;condition: is it rain?</code></li>
<li><code>inputoutput</code>：输入输出</li>
</ul>
<h2 id="定义执行走向"><a href="#定义执行走向" class="headerlink" title="定义执行走向"></a>定义执行走向</h2><ul>
<li>使用<code>-&gt;</code>连接两个元素(标签)</li>
<li>对于<code>condition</code>类型，有<code>cond(yes)</code>和<code>cond(no)</code>两种控制走向的语法</li>
<li>其他元素也可以控制分支方向，默认<code>向下</code>，使用<code>right</code>向右，例<code>sb1(right)</code></li>
</ul>
<h2 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">st=&gt;start: Home</span><br><span class="line">e=&gt;end: Restaurant</span><br><span class="line">op1=&gt;operation: get out to eat</span><br><span class="line">cond=&gt;condition: is it rain?</span><br><span class="line">sb1=&gt;subroutine: go back and try again</span><br><span class="line">op2=&gt;operation: arrive</span><br><span class="line">st-&gt;op1-&gt;cond</span><br><span class="line">cond(yes)-&gt;op2-&gt;e</span><br><span class="line">cond(no)-&gt;sb1(right)-&gt;op1</span><br></pre></td></tr></table></figure>
<p><img src="/images/example-flowchart.png" alt="flowchart"></p>
<h1 id="sequence"><a href="#sequence" class="headerlink" title="sequence"></a>sequence</h1><p>sequence语法仅一种格式，即A到B的路径，外加可控制的note</p>
<h2 id="定义元素-1"><a href="#定义元素-1" class="headerlink" title="定义元素"></a>定义元素</h2><p><img src="/images/sequence-grammar.png" alt="sequence grammar"></p>
<h3 id="说明-1"><a href="#说明-1" class="headerlink" title="说明"></a>说明</h3><ul>
<li>路径：包含两种线型和两种箭头，共四种组合方式</li>
<li><strong>note</strong>：旁注</li>
</ul>
<h2 id="实例-1"><a href="#实例-1" class="headerlink" title="实例"></a>实例</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">Title: Here is a title</span><br><span class="line">A-&gt;B: Normal line</span><br><span class="line">B--&gt;C: Dashed line</span><br><span class="line">C-&gt;&gt;D: Open arrow</span><br><span class="line">D--&gt;&gt;A: Dashed open arrow</span><br><span class="line">Note left of A: Note to the\n left of A</span><br><span class="line">Note right of A: Note to the\n right of A</span><br><span class="line">Note over A: Note over A</span><br><span class="line">Note over A,B: Note over both A and B</span><br></pre></td></tr></table></figure>
<p><img src="/images/example-sequence.PNG" alt="js sequence diagrams"></p>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://bramp.github.io/js-sequence-diagrams/" target="_blank" rel="noopener">js-sequence-diagrams/Turns text into UML sequence diagrams</a></p>
<h1 id="附"><a href="#附" class="headerlink" title="附"></a>附</h1><p>未完待续，后面还会介绍mathjax用法，这个在这个模板里直接就可以使用，而以上两个属性暂时还不支持，应该是和js调用有关，太麻烦，我只是想使用，便于展示总结，所以暂时使用截图</p>

          
        
      
    </div>

    

    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
  </section>

  
  <nav class="pagination">
    <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><a class="extend next" rel="next" href="/page/2/"><i class="fa fa-angle-right" aria-label="下一页"></i></a>
  </nav>



          </div>
          

        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      

      <section class="site-overview-wrap sidebar-panel sidebar-panel-active">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <p class="site-author-name" itemprop="name">renzheng</p>
              <p class="site-description motion-element" itemprop="description"></p>
          </div>

          
            <nav class="site-state motion-element">
              
                <div class="site-state-item site-state-posts">
                
                  <a href="/archives/">
                
                    <span class="site-state-item-count">12</span>
                    <span class="site-state-item-name">日志</span>
                  </a>
                </div>
              

              
                
                
                <div class="site-state-item site-state-categories">
                  <a href="/categories/index.html">
                    
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                    <span class="site-state-item-count">6</span>
                    <span class="site-state-item-name">分类</span>
                  </a>
                </div>
              

              
                
                
                <div class="site-state-item site-state-tags">
                  <a href="/tags/index.html">
                    
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                    <span class="site-state-item-count">7</span>
                    <span class="site-state-item-name">标签</span>
                  </a>
                </div>
              
            </nav>
          

          

          

          
          

          
          

          
            
          
          

        </div>
      </section>

      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2018</span>
  <span class="with-love" id="animate">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">renzheng</span>

  

  
</div>




  <div class="powered-by">由 <a class="theme-link" target="_blank" href="https://hexo.io">Hexo</a> 强力驱动 v3.7.1</div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">主题 &mdash; <a class="theme-link" target="_blank" href="https://theme-next.org">NexT.Mist</a> v6.3.0</div>




        








        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>


























  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=6.3.0"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=6.3.0"></script>



  
  

  

  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=6.3.0"></script>



  



	





  





  










  





  

  

  

  

  
  

  

  

  

  

  

</body>
</html>
